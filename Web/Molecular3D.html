<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Molecular3D-MMFFOpt</title>

    <!-- 全局和布局样式 -->
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #20232A; /* 使用Draw.html的深色背景作为全局背景 */
        }

        #main-container {
            display: flex;
            height: 100%;
            width: 100%;
        }

        #draw-container, #d3-container {
            height: 100%;
            position: relative;
            overflow: hidden; /* 隐藏内部溢出 */
        }

        #draw-container {
            width: 50%;
            min-width: 200px; /* 最小宽度 */
            display: flex;
            flex-direction: row;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #d3-container {
            flex: 1; /* 占据剩余空间 */
            min-width: 200px; /* 最小宽度 */
        }

        #resizer {
            width: 8px;
            height: 100%;
            background-color: #3C424F;
            cursor: col-resize;
            flex-shrink: 0;
            z-index: 200;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #conversion-controls {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 201;
            /* 新增：背景装饰 */
            padding: 15px 10px;
            background: rgb(60, 66, 79);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #convert-btn {
            writing-mode: vertical-rl;
            text-orientation: upright;
            background: linear-gradient(0deg, rgba(29,155,157,1) 0%, rgba(222,164,39,1) 100%);
            color: white;
            border: none;
            padding: 15px 8px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            letter-spacing: 2px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

            #convert-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
            }

            #convert-btn:active {
                transform: scale(0.95);
            }

            #convert-btn:disabled {
                background: #555;
                cursor: not-allowed;
                opacity: 0.6;
            }

        #server-status {
            writing-mode: vertical-rl;
            text-orientation: upright;
            background: rgba(40, 44, 52, 0.9);
            color: #ddd;
            padding: 10px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #555;
            letter-spacing: 1px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

            #server-status.running {
                background: rgba(76, 175, 80, 0.2);
                border-color: #4CAF50;
                color: #4CAF50;
            }

            #server-status.error {
                background: rgba(200, 67, 54, 0.2);
                border-color: #f44336;
                color: #f44336;
            }

            #server-status.converting {
                background: rgba(255, 193, 7, 0.2);
                border-color: #FFC107;
                color: #FFC107;
            }
    </style>

    <!-- Draw.html 的样式 (已用 #draw-container 作用域限定) -->
    <style>
        #draw-container {
            --bg-dark: #20232A;
            --toolbar-bg: rgba(40, 44, 52, 0.85); /* 修正#2: 增加透明度 */
            --canvas-bg: #FFFFFF;
            --border-color: #3C424F;
            --text-color-light: #F8F8F8;
            --active-bg: #3C424F;
            --hover-bg: #4A515F;
            --atom-color: #61AFEF;
            --bond-color: #98C379;
            --mode-color: #C678DD;
            --delete-color: #E06C75;
            --export-color: #FFD700;
            /* 修正#2: 动态颜色变量 */
            --draw-atom-C: #282C34;
            --draw-atom-H: #A9A9A9;
            --draw-atom-O: #7CBDE6;
            --draw-atom-N: #DAA520;
            --draw-atom-S: #DB9DA6;
            --draw-bond-color: #282C34;
        }

            #draw-container #toolbar {
                width: 120px;
                background: var(--toolbar-bg);
                backdrop-filter: blur(5px); /* 修正#2: 毛玻璃效果 */
                padding: 10px 10px;
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                gap: 10px;
                overflow-y: auto;
                box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
                flex-shrink: 0;
            }

            #draw-container .button-group {
                display: flex;
                flex-direction: column;
                gap: 5px;
                padding-bottom: 5px;
            }

            #draw-container .divider {
                height: 1px;
                background: var(--border-color);
                margin: 1px 0;
            }

            #draw-container .section-title {
                font-size: 10px;
                color: #9DA5B4;
                text-transform: uppercase;
                margin-bottom: 5px;
                text-align: center;
            }

            #draw-container button {
                width: 100%;
                padding: 5px 3px;
                font-size: 12px;
                line-height: 1.2;
                background: transparent;
                border: 1px solid var(--border-color);
                color: var(--text-color-light);
                cursor: pointer;
                border-radius: 4px;
                transition: all 0.2s ease-in-out;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                display: flex;
                align-items: center;
                justify-content: center;
            }

                #draw-container button:hover {
                    background: var(--hover-bg);
                    border-color: var(--hover-bg);
                    color: var(--text-color-light);
                }

                #draw-container button.active {
                    background: var(--active-bg);
                    border-color: var(--active-bg);
                    box-shadow: 0 0 5px rgba(97, 175, 239, 0.8);
                }

            #draw-container #draw-bg-controls {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-top: 5px;
            }

            #draw-container #draw-bg-picker-container {
                width: 25px;
                height: 18px;
                border: 1px solid var(--text-color-light);
                border-radius: 4px;
                overflow: hidden;
                position: relative;
                cursor: pointer;
            }

            #draw-container #draw-bg-picker {
                width: 150%;
                height: 150%;
                position: absolute;
                top: -25%;
                left: -25%;
                padding: 0;
                border: none;
                cursor: pointer;
                opacity: 0;
            }

            #draw-container .draw-color-swatch {
                width: 16px;
                height: 16px;
                border: 1px solid var(--text-color-light);
                cursor: pointer;
                border-radius: 50%;
                transition: transform 0.1s;
            }

                #draw-container .draw-color-swatch:hover {
                    transform: scale(1.1);
                }

            #draw-container .atom-btn.active {
                color: var(--atom-color);
                border-color: var(--atom-color);
            }

            #draw-container .bond-btn.active {
                color: var(--bond-color);
                border-color: var(--bond-color);
            }

            #draw-container .mode-btn.active {
                color: var(--mode-color);
                border-color: var(--mode-color);
            }

            #draw-container #exportPngBtn {
                background: var(--export-color);
                border-color: var(--export-color);
                color: #282C34;
                font-weight: bold;
                margin-top: 10px;
            }

                #draw-container #exportPngBtn:hover {
                    background: #D4AF37;
                    border-color: #D4AF37;
                }

            #draw-container #deleteBtn {
                background: var(--delete-color);
                border-color: var(--delete-color);
                font-weight: bold;
                margin-top: 5px;
            }

                #draw-container #deleteBtn:hover {
                    background: #B94451;
                    border-color: #B94451;
                }


            #draw-container #canvas-wrapper {
                flex: 1;
                background: var(--canvas-bg);
                overflow: auto; /* ⭐ 改为auto，当内容溢出时显示滚动条 */
                position: relative; /* ⭐ 添加相对定位 */
            }

            #draw-container svg {
                display: block; /* ⭐ 改为block，避免底部留白 */
                cursor: crosshair;
                background-color: var(--canvas-bg);
                /* ⭐ 移除width和height的100%，让JavaScript动态控制 */
            }

                #draw-container svg .selectable-atom {
                    stroke: transparent;
                    fill: transparent;
                    stroke-width: 2;
                    cursor: crosshair !important; /* 改为crosshair */
                }

                    #draw-container svg .selectable-atom.selected {
                        stroke: #FFD700;
                        stroke-width: 2;
                        /*fill: rgba(255, 255, 153, 0.4);*/
                    }

                #draw-container svg .selectable-bond {
                    stroke: transparent;
                    stroke-width: 20;
                    cursor: crosshair !important; /* 改为crosshair */
                }

                    #draw-container svg .selectable-bond.selected {
                        stroke: rgba(255, 208, 0, 0.6);
                    }

                #draw-container svg text {
                    user-select: none;
                    pointer-events: none;
                }

                #draw-container svg .hover-effect {
                    pointer-events: none !important; /* 确保hover效果永不响应鼠标事件 */
                }

            #draw-container .wedge-icon {
                width: 16px;
                height: 10px;
                overflow: visible;
                background-color: var(--toolbar-bg);
                /* 确保SVG图标颜色跟随按钮文本颜色 */
            }

                #draw-container.wedge-icon.active {
                    background-color: var(--active-bg)
                }

                #draw-container.wedge-icon:hover {
                    background-color: var(--hover-bg);
                }

            #draw-container #selectionRect {
                fill: rgba(100, 150, 255, 0.1);
                stroke: #61AFEF;
                stroke-width: 1;
                stroke-dasharray: 4, 2;
            }
    </style>

    <!-- 3D_V3.html 的样式 -->
    <style>
        #d3-container {
            --color-load-light: #FFC09F;
            --color-light-light: #F0B7C6;
            --color-params-light: #B6E0C7;
            --color-export-light: #B0D6F5;
            --color-text-dark: #DDDDDD;
            --color-load-dark: #D48060;
            --color-light-dark: #C47A9A;
            --color-params-dark: #86A890;
            --color-export-dark: #7096B0;
            --color-text-light: #333333;
            /*  新增：导出按钮渐变颜色（浅色主题 - 灰色系） */
            --export-png-dark: #9487B0; /* 偏灰的紫色 */
            --export-stl-dark: #8788B0; /* 偏灰的蓝紫色 */
            --export-glb-dark: #7B8FA3; /* 偏灰的蓝色 */
            /* 导出按钮渐变颜色（深色主题 - 鲜艳的蓝紫渐变） */
            --export-png-light: #C3A4FA; /* 紫色 */
            --export-stl-light: #B7BDFF; /* 蓝紫色 */
            --export-glb-light: #B2CEFA; /* 蓝色 */


            --current-text-color: var(--color-text-light);
            --current-load-color: var(--color-load-dark);
            --current-light-color: var(--color-light-dark);
            --current-params-color: var(--color-params-dark);
            --current-export-color: var(--color-export-dark);
            --current-toggle-active: var(--color-params-dark);
            /*新增：当前导出按钮颜色（默认使用深色主题） */
            --current-export-png: var(--export-png-dark);
            --current-export-stl: var(--export-stl-dark);
            --current-export-glb: var(--export-glb-dark);
            --axis-x-color: #D62828;
            --axis-y-color: #008000;
            --axis-z-color: #0000FF;
            --axis-text-color: #FFFFFF;
        }

        #d3-container {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #FFFFFF;
        }

            #d3-container canvas {
                display: block;
            }

            #d3-container #controls-container-wrapper {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 100;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                line-height: 1.2;
                transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            #d3-container .control-panel {
                padding: 10px;
                margin-bottom: 10px;
                background: rgba(240, 240, 240, 0.35);
                backdrop-filter: blur(5px);
                border-radius: 12px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.15);
                width: 180px;
                box-sizing: border-box;
                color: var(--current-text-color);
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            }

                #d3-container .control-panel h3 {
                    margin-top: 0;
                    margin-bottom: 8px;
                    font-size: 15px;
                    font-weight: 500;
                    color: var(--current-load-color);
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    padding-bottom: 4px;
                    text-shadow: -0.1px -0.1px #000,0.1px 0.1px #ccc;
                }

            #d3-container .control-group {
                margin-bottom: 8px;
            }

                #d3-container .control-group label {
                    color: var(--current-text-color);
                    font-size: 13px;
                    margin-bottom: 2px;
                    display: block;
                }

            /* 修正#3: 隐藏原生input，用label美化 */
            #d3-container input[type="file"] {
                display: none;
            }

            #d3-container .file-upload-label {
                display: block;
                padding: 8px 12px;
                background-color: var(--current-load-color);
                color: #333;
                border-radius: 8px;
                cursor: pointer;
                text-align: center;
                font-weight: 600;
                margin-bottom: 8px;
                transition: background-color 0.2s;
            }

                #d3-container .file-upload-label:hover {
                    opacity: 0.9;
                }

            #d3-container #status-message {
                font-size: 13px;
                margin-top: 5px;
                margin-bottom: 0;
                line-height: 1.2;
                color: var(--current-load-color);
            }

            #d3-container button {
                padding: 5px 10px;
                cursor: pointer;
                box-sizing: border-box;
                margin-top: 5px;
                border: none;
                border-radius: 8px;
                font-weight: 600;
                transition: all 0.2s;
                box-shadow: 0 3px 0 0 rgba(0, 0, 0, 0.2);
                color: #FFF;
            }

                #d3-container button:hover {
                    opacity: 0.9;
                    transform: translateY(-1px);
                    box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.2);
                }

                #d3-container button:active {
                    transform: translateY(2px);
                    box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.2);
                }

            #d3-container #export-controls-panel .export-button:nth-child(2) {
                /* PNG按钮 */
                background-color: var(--current-export-png);
            }

            #d3-container #export-controls-panel .export-button.export-stl-button {
                /* STL按钮 */
                background-color: var(--current-export-stl);
            }

            #d3-container #export-controls-panel .export-button.export-glb-button {
                /* GLB按钮 */
                background-color: var(--current-export-glb);
            }

            #d3-container #render-buttons {
                display: flex;
                gap: 6px;
                margin-top: 8px;
            }

                #d3-container #render-buttons button {
                    width: 50%;
                    background-color: var(--current-load-color);
                }

            #d3-container #light-presets {
                display: flex;
                gap: 6px;
                margin-top: 8px;
            }

                #d3-container #light-presets button {
                    width: 50%;
                    background-color: var(--current-light-color);
                }

            #d3-container #export-controls-panel button {
                width: 100%;
                background-color: var(--current-export-color);
            }

            #d3-container .light-control-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 5px;
                color: var(--current-text-color);
            }

            #d3-container #hydrogen-toggle-group {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
            }

                #d3-container #hydrogen-toggle-group label:first-child {
                    display: inline;
                    margin-bottom: 0;
                }

            #d3-container .light-control-row input[type="range"] {
                width: 100%;
                height: 4px;
                -webkit-appearance: none;
                background: rgba(255, 255, 255, 0.5);
                border: 1px solid rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                margin: 5px 0;
                box-shadow: none;
            }

                #d3-container .light-control-row input[type="range"]::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: var(--current-export-color);
                    cursor: pointer;
                    box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
                }

            #d3-container #background-picker-group-wrapper {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            #d3-container #background-color-picker-container {
                width: 25px;
                height: 18px;
                border: 1px solid var(--current-text-color);
                border-radius: 4px;
                margin-left: 5px;
                overflow: hidden;
                position: relative;
                cursor: pointer;
                transition: border-color 0.3s;
            }

            #d3-container #background-color-picker {
                width: 150%;
                height: 150%;
                position: absolute;
                top: -25%;
                left: -25%;
                padding: 0;
                border: none;
                cursor: pointer;
                opacity: 0;
            }

            #d3-container #background-picker-group {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            #d3-container .color-swatch {
                width: 20px;
                height: 20px;
                border: 1px solid var(--current-text-color);
                cursor: pointer;
                border-radius: 50%;
                transition: transform 0.1s;
            }

                #d3-container .color-swatch:hover {
                    transform: scale(1.1);
                    box-shadow: 0 0 5px var(--current-text-color);
                }

            #d3-container #highlight-info {
                position: absolute;
                bottom: 40px;
                left: 10px;
                z-index: 100;
                font-family: Arial, sans-serif;
                font-size: 14px;
                line-height: 1.4;
                padding: 5px;
                background: none;
                color: #FFFFFF;
                text-shadow: none;
            }

            #d3-container #toggle-button-wrapper {
                position: absolute;
                bottom: 10px;
                left: 10px;
                z-index: 101;
                font-family: Arial, sans-serif;
                font-size: 14px;
                display: flex;
                align-items: center;
                color: #FFFFFF;
                text-shadow: none;
            }

            #d3-container #controls-label {
                margin-right: 8px;
                white-space: nowrap;
            }

            #d3-container .toggle-switch {
                position: relative;
                display: inline-block;
                width: 64px;
                height: 20px;
            }

                #d3-container .toggle-switch input {
                    opacity: 0;
                    width: 0;
                    height: 0;
                }

            #d3-container .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #444;
                transition: background-color .4s;
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0 6px;
                color: #E0E0E0;
                font-weight: 500;
                font-size: 11px;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4);
                text-shadow: none;
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            }

                #d3-container .slider:before {
                    position: absolute;
                    content: "";
                    height: 14px;
                    width: 14px;
                    left: 3px;
                    bottom: 3px;
                    background-color: #FFFFFF;
                    transition: transform .4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                    border-radius: 50%;
                    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
                }

            #d3-container .toggle-switch input:checked + .slider {
                background-color: var(--current-toggle-active);
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
                color: #333;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider:before {
                transform: translateX(41px);
            }

            #d3-container .toggle-switch input:checked + .slider:before {
                transform: translateX(0);
            }

            #d3-container .slider-text-off {
                position: absolute;
                left: 6px;
                opacity: 1;
                transition: opacity .4s;
            }

            #d3-container .slider-text-on {
                position: absolute;
                right: 6px;
                opacity: 0;
                transition: opacity .4s;
            }

            #d3-container .toggle-switch input:checked + .slider .slider-text-off {
                opacity: 0;
            }

            #d3-container .toggle-switch input:checked + .slider .slider-text-on {
                opacity: 1;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider .slider-text-off {
                opacity: 1;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider .slider-text-on {
                opacity: 0;
            }

            #d3-container #axis-renderer-container {
                position: absolute;
                top: 10px;
                left: 10px;
                width: 80px;
                height: 80px;
                z-index: 100;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            }

                #d3-container #axis-renderer-container canvas {
                    position: absolute;
                    top: 0;
                    left: 0;
                }
    </style>
</head>
<body>

    <div id="main-container">
        <!-- 左侧：Draw.html 内容 -->
        <div id="draw-container">
            <div id="toolbar">
                <div class="button-group">
                    <div class="section-title">原子 (Atom)</div>
                    <button data-tool="C" class="atom-btn active">C</button>
                    <button data-tool="H" class="atom-btn">H</button>
                    <button data-tool="O" class="atom-btn">O</button>
                    <button data-tool="N" class="atom-btn">N</button>
                    <button data-tool="S" class="atom-btn">S</button>
                </div>
                <div class="divider"></div>
                <div class="button-group">
                    <div class="section-title">键 (Bond)</div>
                    <button data-bond="single" class="bond-btn active">单键</button>
                    <button data-bond="double" class="bond-btn">双键</button>
                    <button data-bond="triple" class="bond-btn">三键</button>

                    <button data-bond="wedge-up" class="bond-btn" id="wedgeUpBtn">
                        <svg class="wedge-icon" viewBox="0 0 16 10">
                            <polygon points="0,5 16,10 16,0" fill="#fff" />
                        </svg>
                    </button>
                    <button data-bond="wedge-down" class="bond-btn" id="wedgeDownBtn">
                        <svg class="wedge-icon" viewBox="0 0 16 10">
                            <g fill="#fff">
                                <polygon points="0,5 4,7 4,3" />
                                <polygon points="6,6 10,8 10,2 6,4" />
                                <polygon points="12,2 12,8 16,10 16,0" />
                            </g>
                        </svg>
                    </button>
                </div>
                <div class="divider"></div>
                <div class="button-group">
                    <div class="section-title">功能 (Tool)</div>
                    <button id="drawBtn" class="mode-btn active">✏️ 构造</button>
                    <button id="moveBtn" class="mode-btn">🤚 移动</button>
                    <button id="lassoBtn" class="mode-btn">🔲 套索</button>
                    <button id="exportPngBtn">📷 导出 PNG</button>

                    <button id="deleteBtn">🗑️ 删除</button>
                    <!-- 修正#1: 新增背景选择栏 -->
                    <div class="section-title" style="margin-top: 10px;">背景 (Background)</div>
                    <div id="draw-bg-controls">
                        <div id="draw-bg-picker-container" style="background-color: #FFFFFF;">
                            <input type="color" id="draw-bg-picker" value="#FFFFFF">
                        </div>
                        <div class="draw-color-swatch" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                        <div class="draw-color-swatch" style="background-color: #888888;" data-color="#888888"></div>
                        <div class="draw-color-swatch" style="background-color: #000000;" data-color="#000000"></div>
                    </div>


                </div>
            </div>
            <div id="canvas-wrapper">
                <svg id="draw-svg"></svg>
            </div>
        </div>

        <!-- 拖动条 -->
        <div id="resizer">
            <div id="conversion-controls">
                <button id="convert-btn">3D构象生成</button>
                <div id="server-status">未连接</div>
            </div>
        </div>

        <!-- 右侧：3D_V3.html 内容 (HTML调整为单一文件输入) -->
        <div id="d3-container">
            <div id="axis-renderer-container"></div>
            <!-- 修改highlight-info部分（约第1124行） -->
            <div id="highlight-info">
                <div>原子符号：<span id="highlight-symbol">无</span></div>
                <div>原子编号：<span id="highlight-index">--</span></div>
                <div>原子颜色：<span id="highlight-color">#--</span></div>
                <div>原子坐标：<span id="highlight-coords">----</span></div>
                <div>分子CanSmiles：<span id="highlight-smiles">--</span></div>
            </div>
            <div id="toggle-button-wrapper">
                <span id="controls-label">功能区:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="controls-toggle" checked>
                    <span class="slider">
                        <span class="slider-text-on">开</span>
                        <span class="slider-text-off">关</span>
                    </span>
                </label>
            </div>
            <div id="controls-container-wrapper">
                <div id="file-input-panel" class="control-panel">
                    <h3>模型选择</h3>
                    <div id="render-buttons">
                        <button class="load-button" onclick="d3App.loadAndDraw('ball_stick')">球棍</button>
                        <button class="load-button" onclick="d3App.loadAndDraw('stick')">棒状</button>
                    </div>
                    <p id="status-message">等待从左侧画布转换数据...</p>
                </div>
                <div id="light-controls-panel" class="control-panel">
                    <h3>光照调节</h3>
                    <div class="control-group">
                        <label>环境光强度 (<span id="ambient-value">4.0</span>)</label>
                        <div class="light-control-row">
                            <input type="range" id="ambient-light-range" min="0.0" max="5.0" step="0.1" value="4.0">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>平行光强度 (<span id="directional-value">0.0</span>)</label>
                        <div class="light-control-row">
                            <input type="range" id="directional-light-range" min="0.0" max="2.0" step="0.1" value="0.0">
                        </div>
                    </div>
                    <div id="light-presets">
                        <button class="light-button" onclick="d3App.setLightPreset('clear')">清透</button>
                        <button class="light-button" onclick="d3App.setLightPreset('3d')">立体</button>
                    </div>
                </div>
                <div id="params-controls-panel" class="control-panel">
                    <h3>参数修改</h3>
                    <div class="control-group">
                        <label>背景颜色</label>
                        <div id="background-picker-group-wrapper">
                            <div id="background-color-picker-container" style="background-color: #FFFFFF;">
                                <input type="color" id="background-color-picker" value="#FFFFFF">
                            </div>
                            <div id="background-picker-group">
                                <div class="color-swatch" style="background-color: #000000;" data-color="#000000"></div>
                                <div class="color-swatch" style="background-color: #888888;" data-color="#888888"></div>
                                <div class="color-swatch" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                            </div>
                        </div>
                    </div>
                    <div class="control-group" id="hydrogen-toggle-group">
                        <label>显示H</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="show-hydrogen" checked>
                            <span class="slider">
                                <span class="slider-text-on">是</span>
                                <span class="slider-text-off">否</span>
                            </span>
                        </label>
                    </div>
                </div>
                <div id="export-controls-panel" class="control-panel">
                    <h3>分子导出</h3>
                    <button class="export-button" onclick="d3App.exportView('png')">导出 PNG 图片</button>
                    <button class="export-button export-stl-button" onclick="d3App.exportView('stl')">导出 STL 模型</button>
                    <button class="export-button export-glb-button" onclick="d3App.exportView('glb')">导出 GLB 模型</button>
                </div>
            </div>
        </div>
    </div>
    <!-- 依赖库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvg/3.0.10/canvg.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <!-- 新增：GLTFExporter用于导出GLB格式 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <!-- 拖动条脚本 -->
    <script>
        // Socket通信管理
        const socketManager = {
            serverUrl: 'http://localhost:8765',
            isConnected: false,
            isConverting: false,

            updateStatus: function (status, message) {
                const statusEl = document.getElementById('server-status');
                const convertBtn = document.getElementById('convert-btn');

                statusEl.className = status;
                statusEl.textContent = message;

                if (status === 'running') {
                    convertBtn.disabled = false;
                } else if (status === 'converting') {
                    convertBtn.disabled = true;
                } else {
                    convertBtn.disabled = true;
                }
            },

            checkConnection: async function () {
                if (this.isConverting) {
                    return true;
                }
                try {
                    const response = await fetch(this.serverUrl + '/status', {
                        method: 'GET',
                        signal: AbortSignal.timeout(1000)
                    });

                    if (response.ok) {
                        this.updateStatus('running', '服务已连接');
                        this.isConnected = true;
                        return true;
                    }
                } catch (error) {
                    this.updateStatus('error', '未连接');
                    this.isConnected = false;
                    return false;
                }
            },

            sendData: async function (jsonData) {
                // 标记转换开始
                this.isConverting = true;
                this.updateStatus('converting', '转换中...');

                try {
                    const response = await fetch(this.serverUrl + '/convert', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: jsonData,
                        signal: AbortSignal.timeout(600000) // 600秒超时
                    });

                    if (!response.ok) {
                        throw new Error('服务器响应错误: ' + response.status);
                    }

                    const result = await response.json();
                    this.updateStatus('running', '服务运行中');
                    return result;
                } catch (error) {
                    console.error('发送数据失败:', error);
                    this.updateStatus('error', '转换失败');

                    let errorMsg = '转换失败：' + error.message + "\n\n";
                    if (error.message === "signal time out") {
                        errorMsg += "转换超时，服务器正在计算，有概率计算失败。\n请勿关闭网页，请稍后再次转换。"
                    }
                    else {
                        errorMsg += + '请确认：\n';
                        errorMsg += '1. C++程序正在运行\n';
                        errorMsg += '2. 端口8765未被占用\n';
                        errorMsg += '3. 防火墙允许本地连接';
                    }
                    alert(errorMsg);
                    return null;
                } finally {
                    // 无论成功或失败，清理转换标志
                    this.isConverting = false;
                }
            }
        };

        // 页面加载时检查连接
        window.addEventListener('DOMContentLoaded', function () {
            // 延迟1秒后开始检查连接，给C++程序启动时间
            setTimeout(() => {
                socketManager.checkConnection();
                // 每5秒检查一次连接状态，若正在转换则跳过
                setInterval(() => {
                    if (!socketManager.isConverting) {
                        socketManager.checkConnection();
                    }
                }, 5000);
            }, 1000);
        });

        // 转换按钮事件
        document.getElementById('convert-btn').addEventListener('click', async function () {
            console.log('转换按钮被点击');

            // 先检查连接
            const connected = await socketManager.checkConnection();
            if (!connected) {
                alert('无法连接到C++程序！\n\n请确保：\n1. Main_MMFF94.exe正在运行\n2. 程序显示"Socket服务器已启动"');
                return;
            }

            // 从Draw部分获取分子数据
            if (!window.drawApp || !window.drawApp.getJsonData) {
                alert('画布数据不可用！');
                return;
            }

            const drawData = window.drawApp.getJsonData();
            if (!drawData || !drawData.Atom || drawData.Atom.length === 0) {
                alert('画布为空，无法转换！\n\n请先在左侧画布中绘制分子结构。');
                return;
            }

            console.log('发送数据:', drawData);

            // 发送到C++程序
            const result = await socketManager.sendData(JSON.stringify(drawData));

            // 在转换按钮的click事件处理中，修改两处调用
            if (result && result.status === 'success' && result.data) {
                console.log('接收到3D数据:', result.data);
                console.log('接收到SMILES:', result.SMILES);

                // 将数据传递给3D部分（注意：传递整个result对象，包含SMILES）
                if (window.d3App && window.d3App.loadJsonData) {
                    // 🔑 修改：传递包含SMILES的完整数据
                    const fullData = {
                        SMILES: result.SMILES || '--',
                        SXYZ: result.data.SXYZ,
                        ADJ_AB: result.data.ADJ_AB
                    };
                    window.d3App.loadJsonData(fullData);
                    alert('计算转换成功！\n\n3D结构已加载到右侧视图。');
                } else {
                    console.error('3D模块未就绪');
                    alert('3D模块加载失败，请刷新页面重试。');
                }
            }
            if (result && result.status === 'precal' && result.data) {
                console.log('接收到3D数据:', result.data);
                console.log('接收到SMILES:', result.SMILES);

                // 将数据传递给3D部分
                if (window.d3App && window.d3App.loadJsonData) {
                    // 🔑 修改：传递包含SMILES的完整数据
                    const fullData = {
                        SMILES: result.SMILES || '--',
                        SXYZ: result.data.SXYZ,
                        ADJ_AB: result.data.ADJ_AB
                    };
                    window.d3App.loadJsonData(fullData);
                    alert('转换成功！\n\n服务器将继续计算请求，预计将断联一段时间。\n\n3D结构已加载到右侧视图。');
                } else {
                    console.error('3D模块未就绪');
                    alert('3D模块加载失败，请刷新页面重试。');
                }
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            const resizer = document.getElementById('resizer');
            const drawContainer = document.getElementById('draw-container');
            const d3Container = document.getElementById('d3-container');
            let isResizing = false;
            resizer.addEventListener('mousedown', (e) => {
                // 检查是否点击在按钮或状态框上
                if (e.target.id === 'convert-btn' || e.target.id === 'server-status' ||
                    e.target.closest('#conversion-controls')) {
                    return;
                }

                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                if (window.d3App && window.d3App.controls) {
                    window.d3App.controls.enabled = false;
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const mainRect = document.getElementById('main-container').getBoundingClientRect();
                let newDrawWidth = e.clientX - mainRect.left;
                const minDrawWidth = parseInt(getComputedStyle(drawContainer).minWidth, 10);
                const minD3Width = parseInt(getComputedStyle(d3Container).minWidth, 10);
                if (newDrawWidth < minDrawWidth) newDrawWidth = minDrawWidth;
                if (mainRect.width - newDrawWidth - resizer.offsetWidth < minD3Width) {
                    newDrawWidth = mainRect.width - minD3Width - resizer.offsetWidth;
                }
                drawContainer.style.width = newDrawWidth + 'px';
                if (window.d3App && typeof window.d3App.onWindowResize === 'function') {
                    window.d3App.onWindowResize();
                }
            });
            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.body.style.userSelect = 'auto';
                if (window.d3App && window.d3App.controls) {
                    window.d3App.controls.enabled = true;
                }
            });
        });
    </script>

    <!-- Draw.html 脚本 (已修改：增加 JSON 导出并修复 PNG 导出) -->
    <script>
        (function () {
            function getLuminance(hexColor) {
                const rgb = parseInt(hexColor.slice(1), 16);
                const r = (rgb >> 16) & 0xff;
                const g = (rgb >> 8) & 0xff;
                const b = (rgb >> 0) & 0xff;
                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            }

            function updateDrawTheme(hexColor) {
                const rootStyle = document.getElementById('draw-container').style;
                const isLight = getLuminance(hexColor) > 128;
                rootStyle.setProperty('--canvas-bg', hexColor);
                if (isLight) {
                    rootStyle.setProperty('--draw-atom-C', '#282C34');
                    rootStyle.setProperty('--draw-atom-H', '#A9A9A9');
                    rootStyle.setProperty('--draw-atom-O', '#7CBDE6');
                    rootStyle.setProperty('--draw-atom-N', '#DAA520');
                    rootStyle.setProperty('--draw-atom-S', '#DB9DA6');
                    rootStyle.setProperty('--draw-bond-color', '#282C34');
                } else {
                    rootStyle.setProperty('--draw-atom-C', '#CCCCCC');
                    rootStyle.setProperty('--draw-atom-H', '#A9A9A9');
                    rootStyle.setProperty('--draw-atom-O', '#87CEFA');
                    rootStyle.setProperty('--draw-atom-N', '#FFD700');
                    rootStyle.setProperty('--draw-atom-S', '#FFB6C1');
                    rootStyle.setProperty('--draw-bond-color', '#CCCCCC');
                }
                draw();
            }

            const getCssColor = (elem) => {
                const style = getComputedStyle(document.getElementById('draw-container'));
                if (['C', 'H', 'O', 'N', 'S'].includes(elem)) {
                    return style.getPropertyValue(`--draw-atom-${elem}`).trim();
                }
                return style.getPropertyValue('--draw-bond-color').trim();
            };

            let atoms = [];
            let bonds = [];
            let selectedAtoms = new Set();
            let selectedBonds = new Set();
            let currentTool = 'C';
            let currentBond = 'single';
            let nextAtomId = 1;
            let nextBondId = 1;
            let mode = 'draw';
            let dragStartPos = { x: 0, y: 0 };
            let isDraggingAtom = false;
            let dragTargetId = null;
            let dragStartOffset = { x: 0, y: 0 };
            let isDraggingSelection = false;


            // ⭐ 新增：追踪当前高亮的元素
            let currentHoveredAtomId = null;
            let currentHoveredBondId = null;


            const svg = document.getElementById('draw-svg');
            let isSelecting = false;
            let startX = 0, startY = 0;
            let selectionRect;
            let selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };

            const ATOM_RADIUS = 10;
            const ATOM_FONT_SIZE = '14px';
            const BOND_STROKE_WIDTH = 2;
            const BOND_END_OFFSET = 10;
            const BOND_TYPE_OFFSET = 3;
            const BOND_DOUBLE_OFFSET = 6;
            const WEDGE_WIDTH = 8;
            const HOVER_COLOR = 'rgba(97, 175, 239, 0.5)';
            const SELECT_COLOR = 'rgba(255, 255, 153, 0.4)';
            const CLICK_THRESHOLD = 5;

            // 新增：键和原子的交互范围常量
            const ATOM_HOVER_RADIUS = 10;  // 原子高亮范围（缩小了2px）
            const BOND_HOTSPOT_WIDTH = 20; // 键的可点击范围（从10增加到16）
            const BOND_HOVER_WIDTH = BOND_HOTSPOT_WIDTH;   // 键的hover高亮宽度（从8增加到12）

            let hoverDebounceTimer = null;


            // 暴露获取JSON数据的接口
            window.drawApp = {
                getJsonData: function () {
                    if (!atoms || atoms.length === 0) {
                        return null;
                    }
                    // 按照cpp中AnalysisJsonFile期望的格式生成数据
                    const atomArr = atoms.slice().sort((a, b) => a.id - b.id).map(a => [a.id, a.elem]);
                    const adjArr = bonds.map(b => [b.a1, b.a2, b.type]);
                    return { "Atom": atomArr, "Adj": adjArr };
                }
            };

            // 修改draw函数中双键绘制部分
            function draw() {
                svg.innerHTML = '';

                // ⭐ 创建高亮层容器，放在最底层
                const hoverLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                hoverLayer.setAttribute('id', 'hover-layer');
                svg.appendChild(hoverLayer);

                const atomMap = new Map(atoms.map(a => [a.id, a]));
                const bondCount = atoms.reduce((acc, atom) => {
                    acc[atom.id] = bonds.filter(b => b.a1 === atom.id || b.a2 === atom.id).length;
                    return acc;
                }, {});

                const bondColor = getCssColor('bond');

                const createLine = (x1, y1, x2, y2, strokeWidth = BOND_STROKE_WIDTH, strokeColor = bondColor) => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                    line.setAttribute('stroke', strokeColor);
                    line.setAttribute('stroke-width', strokeWidth);
                    line.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(line);
                };

                const createWedge = (x1, y1, x2, y2, type, fillColor = bondColor) => {
                    const dx = x2 - x1, dy = y2 - y1;
                    const dist = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);
                    const perpAngle = angle + Math.PI / 2;
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                    if (type === 'wedge-up') {
                        const offset = WEDGE_WIDTH / 2;
                        const endOffX = offset * Math.cos(perpAngle), endOffY = offset * Math.sin(perpAngle);
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', `${x1},${y1} ${x2 + endOffX},${y2 + endOffY} ${x2 - endOffX},${y2 - endOffY}`);
                        polygon.setAttribute('fill', fillColor);
                        g.appendChild(polygon);
                    } else if (type === 'wedge-down') {
                        const dashLength = 3, dashGap = 1.5;
                        for (let currentDist = 0; currentDist < dist; currentDist += dashLength + dashGap) {
                            const startRatio = currentDist / dist, endRatio = Math.min(1, (currentDist + dashLength) / dist);
                            const startWidth = WEDGE_WIDTH * (1 - startRatio), endWidth = WEDGE_WIDTH * (1 - endRatio);
                            const p1 = { x: (startWidth / 2) * Math.cos(perpAngle), y: (startWidth / 2) * Math.sin(perpAngle) };
                            const p2 = { x: (endWidth / 2) * Math.cos(perpAngle), y: (endWidth / 2) * Math.sin(perpAngle) };
                            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            polygon.setAttribute('points', `${x2 - startRatio * dx + p1.x},${y2 - startRatio * dy + p1.y} ${x2 - endRatio * dx + p2.x},${y2 - endRatio * dy + p2.y} ${x2 - endRatio * dx - p2.x},${y2 - endRatio * dy - p2.y} ${x2 - startRatio * dx - p1.x},${y2 - startRatio * dy - p1.y}`);
                            polygon.setAttribute('fill', fillColor);
                            g.appendChild(polygon);
                        }
                    }
                    svg.appendChild(g);
                };

                bonds.forEach(b => {
                    const a1 = atomMap.get(b.a1), a2 = atomMap.get(b.a2);
                    if (!a1 || !a2) return;
                    const dx = a2.x - a1.x, dy = a2.y - a1.y, angle = Math.atan2(dy, dx);
                    let startOffset = a1.elem !== 'C' ? BOND_END_OFFSET : 0;
                    let endOffset = a2.elem !== 'C' ? BOND_END_OFFSET : 0;
                    const dist = Math.hypot(dx, dy) - startOffset - endOffset;
                    if (dist <= 0) return;
                    const startX = a1.x + startOffset * Math.cos(angle), startY = a1.y + startOffset * Math.sin(angle);
                    const endX = a2.x - endOffset * Math.cos(angle), endY = a2.y - endOffset * Math.sin(angle);

                    const hotspot = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hotspot.setAttribute('x1', startX); hotspot.setAttribute('y1', startY);
                    hotspot.setAttribute('x2', endX); hotspot.setAttribute('y2', endY);
                    hotspot.setAttribute('class', `selectable-bond${selectedBonds.has(b.id) ? ' selected' : ''}`);
                    hotspot.setAttribute('data-bond-id', b.id);
                    svg.appendChild(hotspot);

                    const strokeColor = bondColor;
                    const offset = BOND_TYPE_OFFSET, perpAngle = angle + Math.PI / 2;
                    const offX = offset * Math.cos(perpAngle), offY = offset * Math.sin(perpAngle);

                    if (b.type === 'double') {

                        // 根据displayStyle绘制不同样式的双键
                        const style = b.displayStyle || 'center';
                        const mainLineLength = Math.hypot(endX - startX, endY - startY);
                        const shortLineRatio = 0.7; // 短线长度为主线的70%
                        const shortLineLength = mainLineLength * shortLineRatio;
                        const shortLineOffset = (mainLineLength - shortLineLength) / 2;

                        if (style === 'center') {

                            // 居中显示（原有画法）
                            createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                            createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                        } else if (style === 'left') {
                            // 左侧短线
                            const offset = BOND_DOUBLE_OFFSET, perpAngle = angle + Math.PI / 2;
                            const offX = offset * Math.cos(perpAngle), offY = offset * Math.sin(perpAngle);
                            createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                            const shortStartX = startX + offX + shortLineOffset * Math.cos(angle);
                            const shortStartY = startY + offY + shortLineOffset * Math.sin(angle);
                            const shortEndX = shortStartX + shortLineLength * Math.cos(angle);
                            const shortEndY = shortStartY + shortLineLength * Math.sin(angle);
                            createLine(shortStartX, shortStartY, shortEndX, shortEndY, BOND_STROKE_WIDTH, strokeColor);
                        } else if (style === 'right') {
                            const offset = BOND_DOUBLE_OFFSET, perpAngle = angle + Math.PI / 2;
                            const offX = offset * Math.cos(perpAngle), offY = offset * Math.sin(perpAngle);
                            // 右侧短线
                            createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                            const shortStartX = startX - offX + shortLineOffset * Math.cos(angle);
                            const shortStartY = startY - offY + shortLineOffset * Math.sin(angle);
                            const shortEndX = shortStartX + shortLineLength * Math.cos(angle);
                            const shortEndY = shortStartY + shortLineLength * Math.sin(angle);
                            createLine(shortStartX, shortStartY, shortEndX, shortEndY, BOND_STROKE_WIDTH, strokeColor);
                        }
                    } else if (b.type === 'triple') {
                        createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                        createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                        createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                    } else if (b.type === 'wedge-up' || b.type === 'wedge-down') {
                        createWedge(startX, startY, endX, endY, b.type, strokeColor);
                    } else {
                        createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                    }
                });

                atoms.forEach(a => {
                    const shouldDrawSymbol = !(a.elem === 'C' && bondCount[a.id] > 0);
                    const clickableCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    clickableCircle.setAttribute('cx', a.x); clickableCircle.setAttribute('cy', a.y);
                    clickableCircle.setAttribute('r', ATOM_RADIUS);
                    clickableCircle.setAttribute('class', `selectable-atom${selectedAtoms.has(a.id) ? ' selected' : ''}`);
                    clickableCircle.setAttribute('data-atom-id', a.id);
                    svg.appendChild(clickableCircle);
                    if (shouldDrawSymbol) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', a.x); text.setAttribute('y', a.y);
                        text.setAttribute('text-anchor', 'middle'); text.setAttribute('dominant-baseline', 'middle');
                        text.setAttribute('fill', getCssColor(a.elem));
                        text.setAttribute('font-size', ATOM_FONT_SIZE);
                        text.setAttribute('font-weight', 'bold');
                        text.textContent = a.elem;
                        text.setAttribute('data-atom-id', a.id);
                        svg.appendChild(text);
                    }
                });

                if (isSelecting && selectionRect) svg.appendChild(selectionRect);
                updateCanvasSize();
            }
            // ⭐ 新增：获取当前视野边界
            function getViewBoundary() {
                const wrapper = document.getElementById('canvas-wrapper');
                return {
                    left: wrapper.scrollLeft,
                    top: wrapper.scrollTop,
                    right: wrapper.scrollLeft + wrapper.clientWidth,
                    bottom: wrapper.scrollTop + wrapper.clientHeight,
                    viewWidth: wrapper.clientWidth,
                    viewHeight: wrapper.clientHeight
                };
            }

            // ⭐ 新增：检查原子是否在padding区域，并返回需要的调整
            function checkAtomPlacementAndAdjust(x, y) {
                const padding = 50;
                const view = getViewBoundary();
                const currentWidth = parseFloat(svg.getAttribute('width')) || view.viewWidth;
                const currentHeight = parseFloat(svg.getAttribute('height')) || view.viewHeight;

                let needCanvasResize = false;
                let newWidth = currentWidth;
                let newHeight = currentHeight;
                let offsetX = 0;
                let offsetY = 0;
                let scrollAdjustX = 0;
                let scrollAdjustY = 0;

                // 检查是否需要扩展画布（原子超出实际边界）
                if (x + padding > currentWidth) {
                    newWidth = x + padding;
                    needCanvasResize = true;
                }
                if (y + padding > currentHeight) {
                    newHeight = y + padding;
                    needCanvasResize = true;
                }

                // 检查是否需要向左扩展画布（原子在左侧padding区域）
                if (x < padding) {
                    offsetX = padding - x;
                    newWidth += offsetX;
                    needCanvasResize = true;
                }

                // 检查是否需要向上扩展画布（原子在顶部padding区域）
                if (y < padding) {
                    offsetY = padding - y;
                    newHeight += offsetY;
                    needCanvasResize = true;
                }

                // 检查视野调整（原子在视野边界的padding区域内）
                const atomInView = {
                    left: x - view.left,
                    top: y - view.top,
                    right: view.right - x,
                    bottom: view.bottom - y
                };

                // 如果原子在视野左侧padding区域
                if (atomInView.left < padding && atomInView.left >= 0) {
                    scrollAdjustX = -(padding - atomInView.left);
                }
                // 如果原子在视野右侧padding区域
                else if (atomInView.right < padding && atomInView.right >= 0) {
                    scrollAdjustX = padding - atomInView.right;
                }

                // 如果原子在视野顶部padding区域
                if (atomInView.top < padding && atomInView.top >= 0) {
                    scrollAdjustY = -(padding - atomInView.top);
                }
                // 如果原子在视野底部padding区域
                else if (atomInView.bottom < padding && atomInView.bottom >= 0) {
                    scrollAdjustY = padding - atomInView.bottom;
                }

                return {
                    needCanvasResize,
                    newWidth,
                    newHeight,
                    offsetX,
                    offsetY,
                    scrollAdjustX,
                    scrollAdjustY
                };
            }

            // ⭐ 修改：updateCanvasSize - 只负责画布大小调整，不再处理视野
            function updateCanvasSize() {
                const wrapper = document.getElementById('canvas-wrapper');
                const rect = wrapper.getBoundingClientRect();

                if (atoms.length === 0) {
                    // 没有原子时，使用容器大小
                    svg.setAttribute('width', rect.width);
                    svg.setAttribute('height', rect.height);
                    return;
                }

                // 计算所有原子的边界框
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                atoms.forEach(a => {
                    minX = Math.min(minX, a.x);
                    minY = Math.min(minY, a.y);
                    maxX = Math.max(maxX, a.x);
                    maxY = Math.max(maxY, a.y);
                });

                const padding = 50;

                // 计算需要的画布大小
                const requiredMinX = minX - padding;
                const requiredMinY = minY - padding;
                const requiredMaxX = maxX + padding;
                const requiredMaxY = maxY + padding;

                // 计算画布的最小尺寸
                const minCanvasWidth = Math.max(rect.width, requiredMaxX);
                const minCanvasHeight = Math.max(rect.height, requiredMaxY);

                let offsetX = 0;
                let offsetY = 0;

                // 检查是否有原子超出左侧或顶部边界
                if (requiredMinX < 0) {
                    offsetX = -requiredMinX;
                }

                if (requiredMinY < 0) {
                    offsetY = -requiredMinY;
                }

                // 只有在需要偏移时才调整原子位置
                if (offsetX > 0 || offsetY > 0) {
                    atoms.forEach(a => {
                        a.x += offsetX;
                        a.y += offsetY;
                    });

                    // 重新绘制以应用偏移
                    draw();
                    return;
                }

                // 设置画布大小
                svg.setAttribute('width', minCanvasWidth);
                svg.setAttribute('height', minCanvasHeight);
            }

            // ⭐ 修改：addAtom - 添加原子前检查并调整
            function addAtom(elem, x, y) {
                const adjustment = checkAtomPlacementAndAdjust(x, y);

                // 1. 如果需要扩展画布，先扩展
                if (adjustment.needCanvasResize) {
                    // 先调整所有现有原子的位置（如果有左/上偏移）
                    if (adjustment.offsetX > 0 || adjustment.offsetY > 0) {
                        atoms.forEach(a => {
                            a.x += adjustment.offsetX;
                            a.y += adjustment.offsetY;
                        });
                        // 调整当前要添加的原子位置
                        x += adjustment.offsetX;
                        y += adjustment.offsetY;
                    }

                    // 设置新的画布大小
                    svg.setAttribute('width', adjustment.newWidth);
                    svg.setAttribute('height', adjustment.newHeight);
                }

                // 2. 添加原子
                atoms.push({ id: nextAtomId++, elem, x, y });

                // 3. 重绘
                draw();

                // 4. 最后调整视野（在draw之后，确保DOM已更新）
                if (adjustment.scrollAdjustX !== 0 || adjustment.scrollAdjustY !== 0) {
                    const wrapper = document.getElementById('canvas-wrapper');
                    // 使用requestAnimationFrame确保在渲染完成后调整滚动
                    requestAnimationFrame(() => {
                        wrapper.scrollLeft += adjustment.scrollAdjustX;
                        wrapper.scrollTop += adjustment.scrollAdjustY;
                    });
                }
            }
            // 修改bond数据结构，添加displayStyle属性
            function addBond(id1, id2) {
                const existing = bonds.find(b => (b.a1 === id1 && b.a2 === id2) || (b.a1 === id2 && b.a2 === id1));
                if (existing) {
                    if (currentBond === 'single') {
                        if (existing.type === 'single') {
                            existing.type = 'double';
                            existing.displayStyle = 'center'; // 默认居中显示
                        } else if (existing.type === 'double') {
                            existing.type = 'triple';
                        } else if (existing.type === 'triple') {
                            existing.type = 'single';
                        }
                    } else {
                        existing.type = currentBond;
                        if (currentBond === 'double') {
                            existing.displayStyle = 'center'; // 重置为居中显示
                        }
                    }
                } else {
                    const newBond = { id: nextBondId++, a1: id1, a2: id2, type: currentBond };
                    if (currentBond === 'double') {
                        newBond.displayStyle = 'center'; // 默认居中显示
                    }
                    bonds.push(newBond);
                }
                draw();
            }
            function extendFrom(atomId, mouseX, mouseY) {
                const parentAtom = atoms.find(a => a.id === atomId);
                if (!parentAtom) return;

                const dx = mouseX - parentAtom.x;
                const dy = mouseY - parentAtom.y;
                let angle = Math.atan2(dy, dx);
                if (angle < 0) {
                    angle += 2 * Math.PI;
                }

                const bondAngles = [
                    0, Math.PI / 6, Math.PI / 3, Math.PI / 2, 2 * Math.PI / 3, 5 * Math.PI / 6, Math.PI,
                    7 * Math.PI / 6, 4 * Math.PI / 3, 3 * Math.PI / 2, 5 * Math.PI / 3, 11 * Math.PI / 6, 2 * Math.PI
                ];

                let closestAngle = bondAngles[0];
                let minDiff = Math.abs(angle - closestAngle);
                for (let i = 1; i < bondAngles.length; i++) {
                    const diff = Math.abs(angle - bondAngles[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestAngle = bondAngles[i];
                    }
                }

                const dist = 40;
                const newX = parentAtom.x + dist * Math.cos(closestAngle);
                const newY = parentAtom.y + dist * Math.sin(closestAngle);

                const overlappingAtom = atoms.find(a =>
                    Math.sqrt(Math.pow(newX - a.x, 2) + Math.pow(newY - a.y, 2)) < ATOM_RADIUS
                );

                if (overlappingAtom) {
                    addBond(parentAtom.id, overlappingAtom.id);
                } else {
                    const newAtomId = nextAtomId;
                    addAtom(currentTool, newX, newY);
                    addBond(parentAtom.id, newAtomId);
                }
            }

            function toggleSelectAtom(atomId) {
                if (selectedAtoms.has(atomId)) {
                    selectedAtoms.delete(atomId);
                } else {
                    selectedAtoms.add(atomId);
                }
                draw();
            }

            function toggleSelectBond(bondId) {
                if (selectedBonds.has(bondId)) {
                    selectedBonds.delete(bondId);
                } else {
                    selectedBonds.add(bondId);
                }
                draw();
            }

            function clearSelection() {
                selectedAtoms.clear();
                selectedBonds.clear();

                // ⭐ 清理hover追踪状态和hover层内容
                currentHoveredAtomId = null;
                currentHoveredBondId = null;
                const hoverLayer = svg.querySelector('#hover-layer');
                if (hoverLayer) {
                    hoverLayer.innerHTML = '';
                }

                if (selectionRect && selectionRect.parentNode) {
                    selectionRect.parentNode.removeChild(selectionRect);
                }
                selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };
                draw();
            }

            function isInsideSelectionBox(x, y) {
                const padding = 5;
                if (selectedAtoms.size === 0) return false;
                if (selectionBox.right - selectionBox.left === 0 || selectionBox.bottom - selectionBox.top === 0) return false;

                return x >= selectionBox.left - padding && x <= selectionBox.right + padding &&
                    y >= selectionBox.top - padding && y <= selectionBox.bottom + padding;
            }

            function getMousePos(e) {
                const rect = svg.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function updateCanvasCursor() {
                svg.classList.remove('move-cursor', 'lasso-cursor');
                if (mode === 'move') {
                    svg.classList.add('move-cursor');
                } else if (mode === 'lasso') {
                    svg.classList.add('lasso-cursor');
                } else {
                    svg.style.cursor = 'crosshair';
                }
            }

            function deleteSelectedElements() {
                const atomsToDelete = new Set(selectedAtoms);
                const bondsToDelete = new Set(selectedBonds);

                if (atomsToDelete.size === 0 && bondsToDelete.size === 0) return;

                // ⭐ 修改：只在选中了原子时，才删除连接到这些原子的键
                if (atomsToDelete.size > 0) {
                    bonds.forEach(b => {
                        if (atomsToDelete.has(b.a1) || atomsToDelete.has(b.a2)) {
                            bondsToDelete.add(b.id);
                        }
                    });
                    // 删除原子
                    atoms = atoms.filter(a => !atomsToDelete.has(a.id));
                }

                // 删除键（如果只选中了键，不会删除原子）
                bonds = bonds.filter(b => !bondsToDelete.has(b.id));

                clearSelection();
            }
            // 修改mousedown事件处理，添加双键样式切换逻辑
            svg.addEventListener('mousedown', e => {
                const pos = getMousePos(e);
                dragStartPos = pos;
                const targetElem = e.target;
                const atomId = targetElem.getAttribute('data-atom-id');
                const bondId = targetElem.getAttribute('data-bond-id');

                if (mode === 'lasso') {
                    if (selectedAtoms.size > 0 && isInsideSelectionBox(pos.x, pos.y)) {
                        isDraggingSelection = true;
                        if (selectionRect && selectionRect.parentNode) {
                            selectionRect.parentNode.removeChild(selectionRect);
                        }
                    } else {
                        isSelecting = true;
                        startX = pos.x;
                        startY = pos.y;
                        if (selectionRect && selectionRect.parentNode) {
                            selectionRect.parentNode.removeChild(selectionRect);
                        }
                        selectionRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        selectionRect.setAttribute('id', 'selectionRect');
                        selectionRect.setAttribute('x', startX);
                        selectionRect.setAttribute('y', startY);
                        selectionRect.setAttribute('width', 0);
                        selectionRect.setAttribute('height', 0);
                        svg.appendChild(selectionRect);
                        clearSelection();
                    }
                } else if (mode === 'move') {
                    if (atomId) {
                        const id = parseInt(atomId);
                        if (!selectedAtoms.has(id)) {
                            clearSelection();
                            toggleSelectAtom(id);
                        }
                        isDraggingAtom = true;
                        dragTargetId = id;
                        const atom = atoms.find(a => a.id === dragTargetId);
                        dragStartOffset.x = pos.x - atom.x;
                        dragStartOffset.y = pos.y - atom.y;
                    } else if (bondId) {
                        // ⭐ 新增：点击键时，只选中键，不选中原子
                        const bond = bonds.find(b => b.id === parseInt(bondId));
                        if (bond) {
                            clearSelection();
                            // ⭐ 只选中键，不添加原子到选择集
                            toggleSelectBond(parseInt(bondId));

                            // 准备拖动这个键（实际上是拖动它的两个原子）
                            isDraggingSelection = true;
                            dragStartPos = pos;

                            // 计算选择框（用于后续拖动）
                            const a1 = atoms.find(a => a.id === bond.a1);
                            const a2 = atoms.find(a => a.id === bond.a2);
                            if (a1 && a2) {
                                selectionBox.left = Math.min(a1.x, a2.x);
                                selectionBox.right = Math.max(a1.x, a2.x);
                                selectionBox.top = Math.min(a1.y, a2.y);
                                selectionBox.bottom = Math.max(a1.y, a2.y);
                            }

                            draw();
                        }
                    } else {
                        clearSelection();
                    }
                } else { // mode === 'draw'
                    if (atomId) {
                        isDraggingAtom = true;
                        dragTargetId = parseInt(atomId);
                    } else if (bondId) {
                        const bond = bonds.find(b => b.id === parseInt(bondId));
                        if (bond) {
                            if (currentBond === 'single') {
                                if (bond.type === 'single') {
                                    bond.type = 'double';
                                    bond.displayStyle = 'center';
                                } else if (bond.type === 'double') {
                                    bond.type = 'triple';
                                    delete bond.displayStyle; // 三键不需要displayStyle
                                } else if (bond.type === 'triple') {
                                    bond.type = 'single';
                                } else {
                                    bond.type = 'single';
                                }
                            } else if (currentBond === 'double') {
                                // 在构造状态下选择了双键按钮，点击双键进行样式切换
                                if (bond.type === 'double') {
                                    // 切换displayStyle: center -> left -> right -> center
                                    const currentStyle = bond.displayStyle || 'center';
                                    if (currentStyle === 'center') {
                                        bond.displayStyle = 'left';
                                    } else if (currentStyle === 'left') {
                                        bond.displayStyle = 'right';
                                    } else {
                                        bond.displayStyle = 'center';
                                    }
                                } else {
                                    // 不是双键，转换为双键并设置默认样式
                                    bond.type = 'double';
                                    bond.displayStyle = 'center';
                                }
                            } else {
                                // 其他键类型
                                bond.type = currentBond;
                                if (currentBond === 'double') {
                                    bond.displayStyle = 'center';
                                } else {
                                    delete bond.displayStyle;
                                }
                            }
                            draw();
                        }
                    } else if (e.target.tagName === 'svg') {
                        addAtom(currentTool, pos.x, pos.y);
                        clearSelection();
                    }
                }
            });
            svg.addEventListener('mousemove', e => {
                const pos = getMousePos(e);

                if (isDraggingSelection) {
                    const dx = pos.x - dragStartPos.x;
                    const dy = pos.y - dragStartPos.y;

                    // ⭐ 修改：如果只选中了键，移动键的端点原子
                    if (selectedBonds.size > 0 && selectedAtoms.size === 0) {
                        // 只有键被选中，移动键的端点
                        selectedBonds.forEach(bondId => {
                            const bond = bonds.find(b => b.id === bondId);
                            if (bond) {
                                const a1 = atoms.find(a => a.id === bond.a1);
                                const a2 = atoms.find(a => a.id === bond.a2);
                                if (a1) {
                                    a1.x += dx;
                                    a1.y += dy;
                                }
                                if (a2) {
                                    a2.x += dx;
                                    a2.y += dy;
                                }
                            }
                        });
                    } else {
                        // 原有逻辑：移动选中的原子
                        selectedAtoms.forEach(id => {
                            const atom = atoms.find(a => a.id === id);
                            if (atom) {
                                atom.x += dx;
                                atom.y += dy;
                            }
                        });
                    }

                    selectionBox.left += dx;
                    selectionBox.right += dx;
                    selectionBox.top += dy;
                    selectionBox.bottom += dy;

                    dragStartPos = pos;
                    draw();
                    return;
                }

                if (mode === 'lasso' && isSelecting) {
                    const width = Math.abs(pos.x - startX);
                    const height = Math.abs(pos.y - startY);
                    const newX = Math.min(pos.x, startX);
                    const newY = Math.min(pos.y, startY);
                    selectionRect.setAttribute('x', newX);
                    selectionRect.setAttribute('y', newY);
                    selectionRect.setAttribute('width', width);
                    selectionRect.setAttribute('height', height);
                    return;
                }

                if (mode === 'move' && isDraggingAtom) {
                    const atom = atoms.find(a => a.id === dragTargetId);
                    if (atom) {
                        atom.x = pos.x - dragStartOffset.x;
                        atom.y = pos.y - dragStartOffset.y;
                        draw();
                    }
                    return;
                }


                if (!isDraggingSelection && !(mode === 'lasso' && isSelecting)) {
                    const targetElem = e.target;

                    // ⭐ 关键修复：忽略hover效果元素本身
                    if (targetElem.classList.contains('hover-effect')) {
                        return;
                    }

                    const atomId = targetElem.getAttribute('data-atom-id');
                    const bondId = targetElem.getAttribute('data-bond-id');

                    // 转换为整数或null
                    const newHoveredAtomId = atomId ? parseInt(atomId) : null;
                    const newHoveredBondId = bondId ? parseInt(bondId) : null;

                    // ⭐ 检查高亮状态是否真正改变
                    const atomChanged = newHoveredAtomId !== currentHoveredAtomId;
                    const bondChanged = newHoveredBondId !== currentHoveredBondId;

                    // 只有当高亮对象改变时才重绘
                    if (atomChanged || bondChanged) {
                        // 清除之前的定时器
                        if (hoverDebounceTimer) {
                            clearTimeout(hoverDebounceTimer);
                        }

                        // ⭐ 添加10ms延迟防抖
                        hoverDebounceTimer = setTimeout(() => {
                            currentHoveredAtomId = newHoveredAtomId;
                            currentHoveredBondId = newHoveredBondId;

                            // ⭐ 获取高亮层容器
                            const hoverLayer = svg.querySelector('#hover-layer');
                            if (hoverLayer) {
                                // 清空高亮层的内容
                                hoverLayer.innerHTML = '';
                            }

                            const atomMapForHover = new Map(atoms.map(a => [a.id, a]));

                            // 绘制原子hover效果
                            if (newHoveredAtomId && !selectedAtoms.has(newHoveredAtomId)) {
                                const atom = atoms.find(a => a.id === newHoveredAtomId);
                                if (atom && hoverLayer) {
                                    const hoverCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                    hoverCircle.setAttribute('cx', atom.x);
                                    hoverCircle.setAttribute('cy', atom.y);
                                    hoverCircle.setAttribute('r', ATOM_HOVER_RADIUS);
                                    hoverCircle.setAttribute('stroke', HOVER_COLOR);
                                    hoverCircle.setAttribute('stroke-width', 2);
                                    hoverCircle.setAttribute('fill', 'none');
                                    hoverCircle.setAttribute('class', 'hover-effect');
                                    hoverCircle.setAttribute('pointer-events', 'none');
                                    // ⭐ 添加到底层容器而不是顶层
                                    hoverLayer.appendChild(hoverCircle);
                                }
                            }
                            // 绘制键hover效果
                            else if (newHoveredBondId && !selectedBonds.has(newHoveredBondId)) {
                                const bond = bonds.find(b => b.id === newHoveredBondId);
                                if (bond && hoverLayer) {
                                    const a1 = atomMapForHover.get(bond.a1);
                                    const a2 = atomMapForHover.get(bond.a2);
                                    if (a1 && a2) {
                                        const hoverLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                        hoverLine.setAttribute('x1', a1.x);
                                        hoverLine.setAttribute('y1', a1.y);
                                        hoverLine.setAttribute('x2', a2.x);
                                        hoverLine.setAttribute('y2', a2.y);
                                        hoverLine.setAttribute('stroke', HOVER_COLOR);
                                        hoverLine.setAttribute('stroke-width', BOND_HOVER_WIDTH);
                                        hoverLine.setAttribute('class', 'hover-effect');
                                        hoverLine.setAttribute('pointer-events', 'none');
                                        // ⭐ 添加到底层容器而不是顶层
                                        hoverLayer.appendChild(hoverLine);
                                    }
                                }
                            }
                        }, 30);
                    }
                }
            });
            svg.addEventListener('mouseup', e => {
                const pos = getMousePos(e);
                dragEndPos = pos;
                const dragDistance = Math.sqrt(Math.pow(dragEndPos.x - dragStartPos.x, 2) + Math.pow(dragEndPos.y - dragStartPos.y, 2));

                if (isDraggingSelection) {
                    isDraggingSelection = false;
                    draw();
                    return;
                }

                if (mode === 'lasso') {
                    isSelecting = false;
                    if (selectionRect) {
                        svg.removeChild(selectionRect);
                        selectionRect = null;
                    }

                    if (dragDistance > CLICK_THRESHOLD) {
                        const endX = pos.x;
                        const endY = pos.y;
                        const left = Math.min(startX, endX);
                        const top = Math.min(startY, endY);
                        const width = Math.abs(startX - endX);
                        const height = Math.abs(startY - endY);

                        selectionBox.left = left;
                        selectionBox.top = top;
                        selectionBox.right = left + width;
                        selectionBox.bottom = top + height;

                        atoms.forEach(a => {
                            if (a.x >= left && a.x <= left + width && a.y >= top && a.y <= top + height) {
                                selectedAtoms.add(a.id);
                            }
                        });
                        bonds.forEach(b => {
                            const a1 = atoms.find(a => a.id === b.a1);
                            const a2 = atoms.find(a => a.id === b.a2);
                            if (!a1 || !a2) return;
                            if (selectedAtoms.has(a1.id) && selectedAtoms.has(a2.id)) {
                                selectedBonds.add(b.id);
                            }
                        });
                    } else {
                        if (!isInsideSelectionBox(pos.x, pos.y)) {
                            clearSelection();
                        }
                    }
                    draw();
                } else if (mode === 'move') {
                    isDraggingAtom = false;
                    dragTargetId = null;
                    draw();
                } else if (mode === 'draw' && isDraggingAtom) {
                    if (dragDistance < CLICK_THRESHOLD) {
                        const targetAtom = atoms.find(a => a.id === dragTargetId);
                        if (targetAtom) {
                            targetAtom.elem = currentTool;
                        }
                    } else {
                        const targetAtom = atoms.find(a => a.id !== dragTargetId && Math.sqrt(Math.pow(pos.x - a.x, 2) + Math.pow(pos.y - a.y, 2)) < ATOM_RADIUS);
                        if (targetAtom) {
                            addBond(dragTargetId, targetAtom.id);
                        } else {
                            extendFrom(dragTargetId, pos.x, pos.y);
                        }
                    }
                    isDraggingAtom = false;
                    dragTargetId = null;
                    draw();
                }

                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: e.clientX,
                    clientY: e.clientY
                });
                svg.dispatchEvent(mouseEvent);
            });

            svg.addEventListener('mouseleave', () => {
                isSelecting = false;
                isDraggingAtom = false;
                isDraggingSelection = false;
                dragTargetId = null;

                // ⭐ 清理hover追踪状态和hover层内容
                currentHoveredAtomId = null;
                currentHoveredBondId = null;

                const hoverLayer = svg.querySelector('#hover-layer');
                if (hoverLayer) {
                    hoverLayer.innerHTML = '';
                }

                if (selectionRect) {
                    svg.removeChild(selectionRect);
                    selectionRect = null;
                }
            });

            document.addEventListener('keydown', e => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    deleteSelectedElements();
                }
            });

            // 导出 PNG：修复实现，排除热点与 hover-effect，保留颜色
            document.getElementById('exportPngBtn').addEventListener('click', () => {
                const svgElement = document.getElementById('draw-svg');
                clearSelection();
                svgElement.querySelectorAll('.hover-effect').forEach(el => el.remove());
                let bbox;
                try {
                    bbox = svgElement.getBBox();
                    if (bbox.width === 0 || bbox.height === 0) {
                        alert('画布为空，无法导出！');
                        return;
                    }
                } catch (e) {
                    alert('画布为空或浏览器不支持，无法导出！');
                    return;
                }
                const margin = 15;
                const width = Math.ceil(bbox.width + 2 * margin);
                const height = Math.ceil(bbox.height + 2 * margin);
                const translateX = -bbox.x + margin;
                const translateY = -bbox.y + margin;
                const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                tempSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                tempSvg.setAttribute('width', width);
                tempSvg.setAttribute('height', height);
                tempSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('transform', `translate(${translateX}, ${translateY})`);
                Array.from(svgElement.children).forEach(child => {
                    if (child.id === 'selectionRect') return;
                    const cls = child.getAttribute('class') || '';
                    if (cls.includes('selectable-atom') || cls.includes('selectable-bond') || cls.includes('hover-effect')) {
                        return;
                    }
                    const clonedChild = child.cloneNode(true);
                    if (clonedChild.tagName === 'text') {
                        const atomId = clonedChild.getAttribute('data-atom-id');
                        const atom = atoms.find(a => a.id === parseInt(atomId));
                        if (atom) clonedChild.setAttribute('fill', getCssColor(atom.elem));
                    }
                    if (clonedChild.tagName === 'line') {
                        const stroke = clonedChild.getAttribute('stroke');
                        if (!stroke) clonedChild.setAttribute('stroke', getCssColor('bond'));
                    }
                    if (clonedChild.tagName === 'g' || clonedChild.tagName === 'polygon' || clonedChild.tagName === 'path') {
                        if (clonedChild.tagName === 'g') {
                            Array.from(clonedChild.querySelectorAll('*')).forEach(ch => {
                                if ((ch.tagName === 'polygon' || ch.tagName === 'path') && !ch.getAttribute('fill')) ch.setAttribute('fill', getCssColor('bond'));
                                if (ch.tagName === 'line' && !ch.getAttribute('stroke')) ch.setAttribute('stroke', getCssColor('bond'));
                            });
                        } else {
                            if ((clonedChild.tagName === 'polygon' || clonedChild.tagName === 'path') && !clonedChild.getAttribute('fill')) clonedChild.setAttribute('fill', getCssColor('bond'));
                        }
                    }
                    g.appendChild(clonedChild);
                });
                tempSvg.appendChild(g);
                const svgData = new XMLSerializer().serializeToString(tempSvg);
                const img = new Image();
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                img.onload = function () {
                    const canvas = document.createElement('canvas');
                    canvas.width = width; canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0);
                    const dataURL = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = dataURL;
                    a.download = 'molecular_structure_transparent.png';
                    document.body.appendChild(a); a.click(); document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };
                img.src = url;
            });

            function downloadJSON(data) {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'molecular_structure.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- 工具栏按钮逻辑 ---
            document.querySelectorAll('#toolbar button').forEach(btn => {
                btn.addEventListener('click', () => {

                    if (btn.id === 'deleteBtn' || btn.id === 'exportPngBtn') {
                        if (btn.id === 'deleteBtn') deleteSelectedElements();
                        // 导出按钮逻辑已在上方实现
                        return;
                    }

                    clearSelection();

                    if (btn.classList.contains('mode-btn')) {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        mode = btn.id === 'drawBtn' ? 'draw' : btn.id === 'moveBtn' ? 'move' : 'lasso';
                    } else if (btn.classList.contains('atom-btn')) {
                        document.querySelectorAll('.atom-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentTool = btn.dataset.tool;
                        document.getElementById('drawBtn').click();
                    } else if (btn.classList.contains('bond-btn')) {
                        document.querySelectorAll('.bond-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentBond = btn.dataset.bond;
                        document.getElementById('drawBtn').click();
                    }
                    updateCanvasCursor();
                });
            });

            // 背景颜色选择器
            const drawBgPicker = document.getElementById('draw-bg-picker');
            const drawBgPickerContainer = document.getElementById('draw-bg-picker-container');
            const drawColorSwatches = document.querySelectorAll('.draw-color-swatch');

            drawBgPicker.addEventListener('input', (e) => {
                updateDrawTheme(e.target.value);
                drawBgPickerContainer.style.backgroundColor = e.target.value;
            });

            drawColorSwatches.forEach(swatch => {
                swatch.addEventListener('click', (e) => {
                    const color = e.target.getAttribute('data-color');
                    drawBgPicker.value = color;
                    updateDrawTheme(color);
                    drawBgPickerContainer.style.backgroundColor = color;
                });
            });

            window.addEventListener('resize', () => {
                // 延迟执行，确保容器已调整大小
                setTimeout(() => {
                    if (atoms.length > 0) {
                        updateCanvasSize();
                    }
                }, 100);
            });

            // 初始设置默认工具
            document.getElementById('drawBtn').click();
            document.querySelector('.atom-btn[data-tool="C"]').classList.add('active');
            document.querySelector('.bond-btn[data-bond="single"]').classList.add('active');

            draw();
        })();
    </script>

    <!-- 3D部分脚本 -->
    <script>
        // 3D应用对象
        window.d3App = (function () {

            const ATOM_RADII = { 'C': 0.77, 'H': 0.37, 'O': 0.73, 'N': 0.75, 'S': 1.02 };
            const ATOM_COLORS = { 'C': 0xBBBBBB, 'H': 0x888888, 'O': 0x6495ED, 'N': 0xB2B01D, 'S': 0xCC99A2 };
            const BALL_STICK_SCALE_FACTOR = 0.4, BOND_RADIUS_BALL_STICK = 0.05, STICK_RADIUS = 0.12;
            const HIGHLIGHT_COLOR = 0xFFFF00, INITIAL_CAMERA_DISTANCE = 15, AXIS_CAMERA_DISTANCE = 3.5;

            let scene, camera, renderer, controls, moleculeGroup, ambientLight, directionalLight;
            let atomMeshes = [], bondMeshes = [], highlightedAtom = null, sxyzData = null, adjData = null;
            let currentRenderType = 'ball_stick', currentBackgroundColor = 0xFFFFFF;
            let axisScene, axisCamera, axisRenderer, axisGroup, axisRendererContainer;
            const AXIS_SIZE = 80;
            // let currentRenderType = 'ball_stick';

            const d3Container = document.getElementById('d3-container');

            function getLuminance(hexColor) {
                if (typeof hexColor === 'number') hexColor = '#' + hexColor.toString(16).padStart(6, '0');
                const r = parseInt(hexColor.slice(1, 3), 16) / 255, g = parseInt(hexColor.slice(3, 5), 16) / 255, b = parseInt(hexColor.slice(5, 7), 16) / 255;
                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            }

            function getButtonTextColor(bgColorHex) { return getLuminance(bgColorHex) > 0.6 ? '#333333' : '#FFFFFF'; }

            function updateControlTextAndThemeColor(hexColor) {
                const root = d3Container.style;
                const isLightBackground = getLuminance(hexColor) > 0.3;
                const theme = isLightBackground ? 'dark' : 'light';
                root.setProperty('--current-text-color', `var(--color-text-${theme === 'dark' ? 'light' : 'dark'})`);
                ['load', 'light', 'params', 'export'].forEach(type => {
                    root.setProperty(`--current-${type}-color`, `var(--color-${type}-${theme})`);
                });
                root.setProperty('--current-toggle-active', `var(--color-params-${theme})`);

                // 🔑 新增：根据主题切换导出按钮颜色
                root.setProperty('--current-export-png', `var(--export-png-${theme})`);
                root.setProperty('--current-export-stl', `var(--export-stl-${theme})`);
                root.setProperty('--current-export-glb', `var(--export-glb-${theme})`);

                setupUIStyles();
                const textColor = getComputedStyle(d3Container).getPropertyValue('--current-text-color');
                d3Container.querySelector('#background-color-picker-container').style.borderColor = textColor;
                d3Container.querySelectorAll('.color-swatch').forEach(swatch => swatch.style.borderColor = textColor);
            }

            function updateInfoTextColor(hexColor) {
                const textColor = getLuminance(hexColor) > 0.5 ? '#000000' : '#FFFFFF';
                d3Container.querySelector('#highlight-info').style.color = textColor;
                d3Container.querySelector('#controls-label').style.color = textColor;
                d3Container.querySelector('#toggle-button-wrapper').style.color = textColor;
            }

            function colorToHex(color) {
                if (typeof color === 'number') return '#' + color.toString(16).padStart(6, '0').toUpperCase();
                if (color instanceof THREE.Color) return '#' + color.getHexString().toUpperCase();
                return '#--';
            }

            function updateHighlightInfo(atom) {
                const symbolEl = d3Container.querySelector('#highlight-symbol'), indexEl = d3Container.querySelector('#highlight-index');
                const colorEl = d3Container.querySelector('#highlight-color'), coordsEl = d3Container.querySelector('#highlight-coords');
                if (atom && atom.userData) {
                    const data = atom.userData;
                    symbolEl.textContent = data.symbol;
                    indexEl.textContent = data.index;
                    const colorHex = colorToHex(data.baseColor);
                    colorEl.textContent = colorHex;
                    colorEl.style.color = colorHex;
                    coordsEl.textContent = `(${(data.X || 0).toFixed(2)}, ${(data.Y || 0).toFixed(2)}, ${(data.Z || 0).toFixed(2)})`;
                } else {
                    symbolEl.textContent = '无'; indexEl.textContent = '--';
                    colorEl.textContent = '#--'; colorEl.style.color = 'inherit';
                    coordsEl.textContent = '----';
                }
            }

            function exportView(format) {
                if (format === 'png') {
                    if (!renderer) return;
                    const originalBackground = scene.background, originalAlpha = renderer.getClearAlpha();
                    scene.background = null;
                    if (renderer.setClearAlpha) renderer.setClearAlpha(0);
                    renderer.render(scene, camera);
                    const imgData = renderer.domElement.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = 'molecule_3d_view.png';
                    link.href = imgData;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    if (renderer.setClearAlpha) renderer.setClearAlpha(originalAlpha);
                    scene.background = originalBackground;
                    renderer.render(scene, camera);
                } else if (format === 'stl') {
                    exportSTL();
                } else if (format === 'glb') {
                    exportGLB();
                }
            }

            function exportSTL() {
                if (!moleculeGroup || atomMeshes.length === 0) {
                    alert('没有可导出的3D模型！');
                    return;
                }

                // 生成STL内容
                let stlString = 'solid molecule\n';

                // 遍历所有mesh对象，提取几何体
                moleculeGroup.traverse((object) => {
                    if (object.isMesh && object.geometry) {
                        const geometry = object.geometry;
                        const matrix = object.matrixWorld;

                        // 确保几何体有索引
                        let positions = geometry.attributes.position;
                        let indices = geometry.index;

                        if (!indices) {
                            // 如果没有索引，创建非索引几何体
                            const tempGeometry = geometry.toNonIndexed();
                            positions = tempGeometry.attributes.position;

                            // 每3个顶点组成一个三角形
                            for (let i = 0; i < positions.count; i += 3) {
                                const v1 = new THREE.Vector3().fromBufferAttribute(positions, i).applyMatrix4(matrix);
                                const v2 = new THREE.Vector3().fromBufferAttribute(positions, i + 1).applyMatrix4(matrix);
                                const v3 = new THREE.Vector3().fromBufferAttribute(positions, i + 2).applyMatrix4(matrix);

                                // 计算法向量
                                const normal = new THREE.Vector3();
                                const edge1 = new THREE.Vector3().subVectors(v2, v1);
                                const edge2 = new THREE.Vector3().subVectors(v3, v1);
                                normal.crossVectors(edge1, edge2).normalize();

                                stlString += `  facet normal ${normal.x.toExponential(6)} ${normal.y.toExponential(6)} ${normal.z.toExponential(6)}\n`;
                                stlString += '    outer loop\n';
                                stlString += `      vertex ${v1.x.toExponential(6)} ${v1.y.toExponential(6)} ${v1.z.toExponential(6)}\n`;
                                stlString += `      vertex ${v2.x.toExponential(6)} ${v2.y.toExponential(6)} ${v2.z.toExponential(6)}\n`;
                                stlString += `      vertex ${v3.x.toExponential(6)} ${v3.y.toExponential(6)} ${v3.z.toExponential(6)}\n`;
                                stlString += '    endloop\n';
                                stlString += '  endfacet\n';
                            }
                        } else {
                            // 有索引的情况
                            for (let i = 0; i < indices.count; i += 3) {
                                const i1 = indices.getX(i);
                                const i2 = indices.getX(i + 1);
                                const i3 = indices.getX(i + 2);

                                const v1 = new THREE.Vector3().fromBufferAttribute(positions, i1).applyMatrix4(matrix);
                                const v2 = new THREE.Vector3().fromBufferAttribute(positions, i2).applyMatrix4(matrix);
                                const v3 = new THREE.Vector3().fromBufferAttribute(positions, i3).applyMatrix4(matrix);

                                // 计算法向量
                                const normal = new THREE.Vector3();
                                const edge1 = new THREE.Vector3().subVectors(v2, v1);
                                const edge2 = new THREE.Vector3().subVectors(v3, v1);
                                normal.crossVectors(edge1, edge2).normalize();

                                stlString += `  facet normal ${normal.x.toExponential(6)} ${normal.y.toExponential(6)} ${normal.z.toExponential(6)}\n`;
                                stlString += '    outer loop\n';
                                stlString += `      vertex ${v1.x.toExponential(6)} ${v1.y.toExponential(6)} ${v1.z.toExponential(6)}\n`;
                                stlString += `      vertex ${v2.x.toExponential(6)} ${v2.y.toExponential(6)} ${v2.z.toExponential(6)}\n`;
                                stlString += `      vertex ${v3.x.toExponential(6)} ${v3.y.toExponential(6)} ${v3.z.toExponential(6)}\n`;
                                stlString += '    endloop\n';
                                stlString += '  endfacet\n';
                            }
                        }
                    }
                });

                stlString += 'endsolid molecule\n';

                // 下载STL文件
                const blob = new Blob([stlString], { type: 'text/plain' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'molecule_3d_model.stl';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

                alert('STL模型导出成功！');
            }
            function exportGLB() {
                if (!moleculeGroup || atomMeshes.length === 0) {
                    alert('没有可导出的3D模型！');
                    return;
                }

                // 使用Three.js的GLTFExporter
                // 需要先加载GLTFExporter库
                if (typeof THREE.GLTFExporter === 'undefined') {
                    alert('正在加载导出器，请稍候...');
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js';
                    script.onload = () => {
                        performGLBExport();
                    };
                    script.onerror = () => {
                        alert('导出器加载失败！请检查网络连接。');
                    };
                    document.head.appendChild(script);
                } else {
                    performGLBExport();
                }
            }

            function performGLBExport() {
                if (!moleculeGroup || atomMeshes.length === 0) {
                    alert('没有可导出的3D模型！');
                    return;
                }

                try {
                    if (typeof THREE.GLTFExporter === 'undefined') {
                        throw new Error('GLTFExporter未加载');
                    }

                    // 🎨 新增：颜色增强函数
                    function enhanceColor(color) {
                        // 将Three.js颜色转换为RGB
                        const r = (color >> 16) & 0xff;
                        const g = (color >> 8) & 0xff;
                        const b = color & 0xff;

                        // 转换到HSL色彩空间以调整饱和度和亮度
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 510; // 归一化到[0,1]

                        if (max === min) {
                            h = s = 0; // 灰色
                        } else {
                            const d = max - min;
                            s = l > 0.5 ? d / (510 - max - min) : d / (max + min);

                            switch (max) {
                                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                                case g: h = ((b - r) / d + 2) / 6; break;
                                case b: h = ((r - g) / d + 4) / 6; break;
                            }
                        }

                        // 🔑 关键调整：
                        // 1. 增加饱和度 30%（让颜色更鲜艳）
                        s = Math.min(1, s * 1.3);

                        // 2. 增加亮度 20%（让颜色更明亮）
                        l = Math.min(0.9, l * 0.6);

                        // 转换回RGB
                        let r2, g2, b2;
                        if (s === 0) {
                            r2 = g2 = b2 = l;
                        } else {
                            const hue2rgb = (p, q, t) => {
                                if (t < 0) t += 1;
                                if (t > 1) t -= 1;
                                if (t < 1 / 6) return p + (q - p) * 6 * t;
                                if (t < 1 / 2) return q;
                                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                                return p;
                            };

                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                            const p = 2 * l - q;
                            r2 = hue2rgb(p, q, h + 1 / 3);
                            g2 = hue2rgb(p, q, h);
                            b2 = hue2rgb(p, q, h - 1 / 3);
                        }

                        // 转换回16进制颜色
                        return (Math.round(r2 * 255) << 16) | (Math.round(g2 * 255) << 8) | Math.round(b2 * 255);
                    }

                    // 创建增强颜色的克隆组
                    const exportGroup = moleculeGroup.clone(true);

                    // 遍历所有mesh，增强颜色
                    exportGroup.traverse((object) => {
                        if (object.isMesh && object.material) {
                            const originalColor = object.material.color.getHex();
                            const enhancedColor = enhanceColor(originalColor);

                            // 创建新材质（不影响原始场景）
                            object.material = object.material.clone();
                            object.material.color.setHex(enhancedColor);

                            // 🎨 增加金属度和减少粗糙度，让颜色更有光泽
                            if (object.material.metalness !== undefined) {
                                object.material.metalness = 0.2; // 轻微金属感
                            }
                            if (object.material.roughness !== undefined) {
                                object.material.roughness = 0.3; // 减少粗糙度，增加光泽
                            }
                        }
                    });

                    const exporter = new THREE.GLTFExporter();

                    const options = {
                        binary: false,
                        trs: false,
                        onlyVisible: true,
                        truncateDrawRange: false,
                        embedImages: true,
                        maxTextureSize: 4096,
                        includeCustomExtensions: false
                    };

                    // 执行导出
                    exporter.parse(
                        exportGroup,  // 使用增强颜色的克隆组
                        function (gltfData) {
                            try {
                                if (typeof gltfData === 'object' && gltfData.scenes !== undefined) {
                                    const gltfJson = JSON.stringify(gltfData);
                                    const jsonBuffer = new TextEncoder().encode(gltfJson);

                                    const jsonChunkLength = jsonBuffer.byteLength;
                                    const jsonPadding = (4 - (jsonChunkLength % 4)) % 4;
                                    const jsonPaddedLength = jsonChunkLength + jsonPadding;
                                    const totalLength = 12 + 8 + jsonPaddedLength;

                                    const glbBuffer = new ArrayBuffer(totalLength);
                                    const glbView = new DataView(glbBuffer);
                                    let offset = 0;

                                    glbView.setUint32(offset, 0x46546C67, true);
                                    offset += 4;
                                    glbView.setUint32(offset, 2, true);
                                    offset += 4;
                                    glbView.setUint32(offset, totalLength, true);
                                    offset += 4;

                                    glbView.setUint32(offset, jsonPaddedLength, true);
                                    offset += 4;
                                    glbView.setUint32(offset, 0x4E4F534A, true);
                                    offset += 4;

                                    const glbArray = new Uint8Array(glbBuffer);
                                    glbArray.set(jsonBuffer, offset);
                                    offset += jsonChunkLength;

                                    for (let i = 0; i < jsonPadding; i++) {
                                        glbArray[offset++] = 0x20;
                                    }

                                    const blob = new Blob([glbBuffer], { type: 'model/gltf-binary' });
                                    downloadBlob(blob, 'molecule_3d_model.glb');
                                    showSuccessMessage(blob.size, atomMeshes.length, bondMeshes.length);
                                }
                                else if (gltfData instanceof ArrayBuffer) {
                                    const blob = new Blob([gltfData], { type: 'model/gltf-binary' });
                                    downloadBlob(blob, 'molecule_3d_model.glb');
                                    showSuccessMessage(blob.size, atomMeshes.length, bondMeshes.length);
                                }
                                else {
                                    throw new Error('未知的导出格式: ' + typeof gltfData);
                                }
                            } catch (convertError) {
                                console.error('GLB转换失败:', convertError);
                                alert('GLB转换失败：' + convertError.message);
                            }
                        },
                        function (error) {
                            console.error('GLB导出失败:', error);
                            alert('GLB导出失败：' + error.message);
                        },
                        options
                    );

                } catch (error) {
                    console.error('导出异常:', error);
                    alert('导出发生错误：' + error.message);
                }
            }

            // 辅助函数：下载Blob
            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.style.display = 'none';
                link.href = url;
                link.download = filename;

                document.body.appendChild(link);
                link.click();

                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    console.log('✅ 文件下载完成，资源已清理');
                }, 1000);
            }

            // 辅助函数：显示成功消息
            function showSuccessMessage(fileSize, atomCount, bondCount) {
                const fileSizeKB = (fileSize / 1024).toFixed(2);
                alert(
                    '✅ GLB模型导出成功！可导入PowerPoint！\n\n' +
                    '📊 文件信息：\n' +
                    '  • 大小: ' + fileSizeKB + ' KB\n' +
                    '  • 格式: GLB 2.0\n' +
                    '  • 原子数: ' + atomCount + '\n' +
                    '  • 键数: ' + bondCount + '\n\n'
                );
            }

            function clearHighlight() {
                if (highlightedAtom) {
                    highlightedAtom.material.emissive.set(0x000000);
                    highlightedAtom = null;
                }
                bondMeshes.forEach(mesh => { if (mesh.userData.isBond) mesh.material.emissive.set(0x000000); });
                updateHighlightInfo(null);
            }

            function highlightAtomAndBonds(atom) {
                clearHighlight();
                if (!atom) return;
                atom.material.emissive.set(HIGHLIGHT_COLOR);
                highlightedAtom = atom;
                updateHighlightInfo(atom);
                if (currentRenderType !== 'stick') return;
                const atomIndex = highlightedAtom.userData.index;
                bondMeshes.forEach(mesh => {
                    if (mesh.userData.isBond) {
                        const { atomAIndex, atomBIndex, atomSide } = mesh.userData;
                        if ((atomAIndex === atomIndex && atomSide === 'A') || (atomBIndex === atomIndex && atomSide === 'B')) {
                            mesh.material.emissive.set(HIGHLIGHT_COLOR);
                        }
                    }
                });
            }

            function initAxisHelper() {
                axisRendererContainer = d3Container.querySelector('#axis-renderer-container');
                axisScene = new THREE.Scene();
                axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                axisCamera.position.set(AXIS_CAMERA_DISTANCE, AXIS_CAMERA_DISTANCE, AXIS_CAMERA_DISTANCE);
                axisCamera.up.set(0, 1, 0); axisCamera.lookAt(0, 0, 0);
                axisRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                axisRenderer.setSize(AXIS_SIZE, AXIS_SIZE);
                axisRenderer.setClearColor(0x000000, 0);
                axisRendererContainer.appendChild(axisRenderer.domElement);
                axisGroup = new THREE.Group();
                axisScene.add(axisGroup);
                const axesData = [
                    { dir: new THREE.Vector3(1.5, 0, 0), color: 0xD62828, text: 'X' },
                    { dir: new THREE.Vector3(0, 1.5, 0), color: 0x008000, text: 'Y' },
                    { dir: new THREE.Vector3(0, 0, 1.5), color: 0x0000FF, text: 'Z' },
                ];
                const cylGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 16);
                axesData.forEach(data => {
                    const material = new THREE.MeshBasicMaterial({ color: data.color });
                    const cylinder = new THREE.Mesh(cylGeom, material);
                    cylinder.position.copy(data.dir).multiplyScalar(0.5);
                    cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), data.dir.clone().normalize());
                    axisGroup.add(cylinder);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture(data.text, data.color), sizeAttenuation: false, depthTest: false }));
                    sprite.position.copy(data.dir).add(new THREE.Vector3(0.3, 0.3, 0.3));
                    sprite.scale.set(0.3, 0.3, 0.3);
                    axisGroup.add(sprite);
                });
                axisScene.add(new THREE.AmbientLight(0xFFFFFF, 1.0));
            }

            function createTextTexture(text, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64; canvas.height = 64;
                context.font = 'Bold 30px Arial';
                context.fillStyle = '#' + new THREE.Color(color).getHexString();
                context.textAlign = 'center'; context.textBaseline = 'middle';
                context.fillText(text, 32, 37);
                return new THREE.CanvasTexture(canvas);
            }

            function updateAxisHelper() {
                if (!axisGroup || !controls) return;
                axisGroup.quaternion.copy(camera.quaternion).invert();
                axisRenderer.render(axisScene, axisCamera);
            }

            function onWindowResize() {
                const rect = d3Container.getBoundingClientRect();
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                renderer.setSize(rect.width, rect.height);
                if (axisCamera) {
                    axisCamera.aspect = 1;
                    axisCamera.updateProjectionMatrix();
                }
            }

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(currentBackgroundColor);

                camera = new THREE.PerspectiveCamera(35, d3Container.clientWidth / d3Container.clientHeight, 0.1, 1000);
                camera.position.set(INITIAL_CAMERA_DISTANCE, INITIAL_CAMERA_DISTANCE, INITIAL_CAMERA_DISTANCE);
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(d3Container.clientWidth, d3Container.clientHeight);
                d3Container.appendChild(renderer.domElement);
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.zIndex = '0';

                initAxisHelper();

                // 🔑 修改：在初始化的最开始就设置UI样式
                // 因为默认背景是白色(0xFFFFFF)，亮度>0.3，应该使用dark主题（灰蓝紫色）
                updateControlTextAndThemeColor(currentBackgroundColor);
                setupUIStyles();
                updateInfoTextColor(currentBackgroundColor);

                ambientLight = new THREE.AmbientLight(0x404040, 4.0);
                scene.add(ambientLight);
                directionalLight = new THREE.DirectionalLight(0xffffff, 0.0);
                directionalLight.position.set(10, 10, 10).normalize();
                scene.add(directionalLight);
                setLightPreset('3d');

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.PAN,
                    MIDDLE: THREE.MOUSE.ROTATE,
                    RIGHT: THREE.MOUSE.DOLLY
                };
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                // controls.minPolarAngle = -Infinity;  // 允许无限向上
                //controls.maxPolarAngle = Infinity;   // 允许无限向下

                controls.addEventListener('change', updateAxisHelper);

                const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
                let isDragging = false;
                renderer.domElement.addEventListener('pointerdown', () => { isDragging = false; });
                renderer.domElement.addEventListener('pointermove', () => { isDragging = true; });
                renderer.domElement.addEventListener('pointerup', (event) => {
                    if (isDragging) return;
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(atomMeshes);
                    const newHighlightedAtom = intersects.length > 0 ? intersects[0].object : null;
                    if (highlightedAtom === newHighlightedAtom) clearHighlight();
                    else highlightAtomAndBonds(newHighlightedAtom);
                }, false);

                window.addEventListener('resize', onWindowResize, false);
                setupLightControls();
                setupParamsControls();
                setupToggleControl();
                onWindowResize();
                controls.target.set(0, 0, 0);
                controls.update();
                updateAxisHelper();
                animate();
                alert('界面初始化完成！\n相关操作方法见Github。');
            }
            function animate() {
                requestAnimationFrame(animate);
                if (controls.enabled) controls.update();
                renderer.render(scene, camera);
                updateAxisHelper();
            }

            function setupUIStyles() {
                const root = getComputedStyle(d3Container);
                const colors = {
                    load: root.getPropertyValue('--current-load-color').trim(),
                    light: root.getPropertyValue('--current-light-color').trim(),
                    export: root.getPropertyValue('--current-export-color').trim(),
                    params: root.getPropertyValue('--current-params-color').trim(),
                    // 🔑 获取导出按钮的颜色
                    exportPng: root.getPropertyValue('--current-export-png').trim(),
                    exportStl: root.getPropertyValue('--current-export-stl').trim(),
                    exportGlb: root.getPropertyValue('--current-export-glb').trim(),
                };

                // 🔑 新增：判断当前主题（根据背景色）
                const isLightBackground = getLuminance(currentBackgroundColor) > 0.3;
                const exportButtonTextColor = isLightBackground ? '#FFFFFF' : '#333333'; // light模式用黑色，dark模式用白色

                d3Container.querySelector('#file-input-panel h3').style.color = colors.load;
                d3Container.querySelectorAll('#file-input-panel .load-button').forEach(btn => {
                    btn.style.backgroundColor = colors.load;
                    btn.style.color = getButtonTextColor(colors.load);
                });
                d3Container.querySelector('#status-message').style.color = colors.load;
                d3Container.querySelector('#light-controls-panel h3').style.color = colors.light;
                d3Container.querySelectorAll('#light-controls-panel .light-button').forEach(btn => {
                    btn.style.backgroundColor = colors.light;
                    btn.style.color = getButtonTextColor(colors.light);
                });
                d3Container.querySelector('#params-controls-panel h3').style.color = colors.params;
                d3Container.querySelector('#export-controls-panel h3').style.color = colors.export;

                // 🔑 修改：导出按钮文字颜色根据主题决定
                d3Container.querySelectorAll('#export-controls-panel .export-button').forEach(btn => {
                    if (btn.classList.contains('export-stl-button')) {
                        btn.style.backgroundColor = colors.exportStl;
                        btn.style.color = exportButtonTextColor; // 使用主题决定的颜色
                    } else if (btn.classList.contains('export-glb-button')) {
                        btn.style.backgroundColor = colors.exportGlb;
                        btn.style.color = exportButtonTextColor; // 使用主题决定的颜色
                    } else {
                        // PNG按钮
                        btn.style.backgroundColor = colors.exportPng;
                        btn.style.color = exportButtonTextColor; // 使用主题决定的颜色
                    }
                });
            }

            function setLightPreset(preset) {
                const p = preset === 'clear' ? { a: 4.0, d: 0.1 } : { a: 2.5, d: 0.8 };
                ambientLight.intensity = p.a;
                directionalLight.intensity = p.d;
                d3Container.querySelector('#ambient-light-range').value = p.a;
                d3Container.querySelector('#directional-light-range').value = p.d;
                d3Container.querySelector('#ambient-value').textContent = p.a.toFixed(1);
                d3Container.querySelector('#directional-value').textContent = p.d.toFixed(1);
            }

            function setupLightControls() {
                const ambientRange = d3Container.querySelector('#ambient-light-range'), dirRange = d3Container.querySelector('#directional-light-range');
                const ambientVal = d3Container.querySelector('#ambient-value'), dirVal = d3Container.querySelector('#directional-value');
                ambientRange.addEventListener('input', (e) => { ambientLight.intensity = parseFloat(e.target.value); ambientVal.textContent = ambientLight.intensity.toFixed(1); });
                dirRange.addEventListener('input', (e) => { directionalLight.intensity = parseFloat(e.target.value); dirVal.textContent = directionalLight.intensity.toFixed(1); });
            }

            function setupParamsControls() {
                const picker = d3Container.querySelector('#background-color-picker'), container = d3Container.querySelector('#background-color-picker-container');
                const hydrogenToggle = d3Container.querySelector('#show-hydrogen'), swatches = d3Container.querySelectorAll('.color-swatch');
                const updateBg = (hex) => {
                    if (!scene) return;
                    scene.background.set(hex);
                    currentBackgroundColor = scene.background.getHex();
                    container.style.backgroundColor = hex;
                    updateInfoTextColor(currentBackgroundColor);
                    updateControlTextAndThemeColor(currentBackgroundColor);
                };
                picker.addEventListener('input', (e) => updateBg(e.target.value));
                swatches.forEach(s => s.addEventListener('click', (e) => { const c = e.target.dataset.color; picker.value = c; updateBg(c); }));
                hydrogenToggle.addEventListener('change', () => { if (sxyzData && adjData) drawMolecule(currentRenderType, sxyzData, adjData); });
                updateBg(picker.value);
            }

            function setupToggleControl() {
                const toggle = d3Container.querySelector('#controls-toggle'), wrapper = d3Container.querySelector('#controls-container-wrapper');
                const updateTransform = () => wrapper.style.transform = toggle.checked ? 'translateX(0)' : `translateX(${wrapper.offsetWidth + 20}px)`;
                updateTransform();
                toggle.addEventListener('change', updateTransform);
                new ResizeObserver(updateTransform).observe(wrapper);
            }

            function drawMolecule(renderType, sxyzData, adjData) {
                if (moleculeGroup) scene.remove(moleculeGroup);
                atomMeshes = []; bondMeshes = []; clearHighlight();
                moleculeGroup = new THREE.Group();
                scene.add(moleculeGroup);
                const showH = d3Container.querySelector('#show-hydrogen').checked;
                const drawFunc = renderType === 'stick' ? drawAtomsAndBonds_Stick : drawAtomsAndBonds_BallStick;
                drawFunc(sxyzData, adjData, showH);
                centerAndZoom(sxyzData);
            }

            function drawAtomsAndBonds_BallStick(sxyzData, adjData, showH) {
                const atomGeom = new THREE.SphereGeometry(1, 32, 32);
                sxyzData.forEach((atom, index) => {
                    const symbol = String(atom.Symbol).trim().toUpperCase();
                    if (!showH && symbol === 'H') return;
                    const radius = (ATOM_RADII[symbol] || 0.5) * BALL_STICK_SCALE_FACTOR;
                    const color = ATOM_COLORS[symbol] || 0xCCCCCC;
                    const material = new THREE.MeshStandardMaterial({ color, emissive: 0x0, metalness: 0.1, roughness: 0.5 });
                    const mesh = new THREE.Mesh(atomGeom, material);
                    mesh.scale.set(radius, radius, radius);
                    mesh.position.set(atom.X, atom.Y, atom.Z);
                    mesh.userData = { ...atom, symbol, index: index + 1, baseColor: color, isAtom: true };
                    atomMeshes.push(mesh);
                    moleculeGroup.add(mesh);
                });

                const bondGeom = new THREE.CylinderGeometry(BOND_RADIUS_BALL_STICK, BOND_RADIUS_BALL_STICK, 1, 16);
                const bondMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.1, roughness: 0.8 });

                adjData.forEach(bond => {
                    const iA = (bond.A || 0) - 1, iB = (bond.B || 0) - 1;
                    if (iA < 0 || iB < 0 || iA >= sxyzData.length || iB >= sxyzData.length) return;
                    const sA = String(sxyzData[iA].Symbol).trim().toUpperCase(), sB = String(sxyzData[iB].Symbol).trim().toUpperCase();
                    if (!showH && (sA === 'H' || sB === 'H')) return;

                    const posA = new THREE.Vector3(sxyzData[iA].X, sxyzData[iA].Y, sxyzData[iA].Z);
                    const posB = new THREE.Vector3(sxyzData[iB].X, sxyzData[iB].Y, sxyzData[iB].Z);
                    const center = new THREE.Vector3().addVectors(posA, posB).divideScalar(2);
                    const bondLength = posA.distanceTo(posB);
                    const direction = new THREE.Vector3().subVectors(posB, posA).normalize();

                    // 获取键型，默认为单键
                    const bondType = bond.BondType || "-";

                    // 根据键型确定绘制的键数量和偏移
                    let bondCount = 1;
                    if (bondType === "=") bondCount = 2;       // 双键
                    else if (bondType === "#") bondCount = 3;  // 三键

                    // 计算垂直于键方向的向量，用于平行键的偏移
                    const perpVector = new THREE.Vector3();
                    if (Math.abs(direction.y) < 0.99) {
                        // 如果键不是垂直的，使用 Y 轴叉乘
                        perpVector.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                    } else {
                        // 如果键接近垂直，使用 X 轴叉乘
                        perpVector.crossVectors(direction, new THREE.Vector3(1, 0, 0)).normalize();
                    }

                    const bondSpacing = BOND_RADIUS_BALL_STICK * 3; // 键之间的间距

                    for (let i = 0; i < bondCount; i++) {
                        const bondMesh = new THREE.Mesh(bondGeom, bondMat.clone());
                        bondMesh.scale.set(1, bondLength, 1);

                        // 计算偏移位置
                        let offset = new THREE.Vector3();
                        if (bondCount === 1) {
                            // 单键：无偏移
                            offset.set(0, 0, 0);
                        } else if (bondCount === 2) {
                            // 双键：在垂直方向上偏移 ±bondSpacing/2
                            offset.copy(perpVector).multiplyScalar((i - 0.5) * bondSpacing);
                        } else if (bondCount === 3) {
                            // 三键：中间一条无偏移，两侧偏移 ±bondSpacing
                            offset.copy(perpVector).multiplyScalar((i - 1) * bondSpacing);
                        }

                        bondMesh.position.copy(center).add(offset);
                        bondMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                        bondMesh.userData = { isBond: true, atomAIndex: iA + 1, atomBIndex: iB + 1 };
                        bondMeshes.push(bondMesh);
                        moleculeGroup.add(bondMesh);
                    }
                });
            }

            function drawAtomsAndBonds_Stick(sxyzData, adjData, showH) {
                const atomGeom = new THREE.SphereGeometry(1, 32, 32);
                sxyzData.forEach((atom, index) => {
                    const symbol = String(atom.Symbol).trim().toUpperCase();
                    if (!showH && symbol === 'H') return;
                    const color = ATOM_COLORS[symbol] || 0xCCCCCC;
                    const material = new THREE.MeshStandardMaterial({ color, emissive: 0x0, metalness: 0.1, roughness: 0.5 });
                    const mesh = new THREE.Mesh(atomGeom, material);
                    mesh.scale.set(STICK_RADIUS, STICK_RADIUS, STICK_RADIUS);
                    mesh.position.set(atom.X, atom.Y, atom.Z);
                    mesh.userData = { ...atom, symbol, index: index + 1, baseColor: color, isAtom: true };
                    atomMeshes.push(mesh);
                    moleculeGroup.add(mesh);
                });
                const bondGeom = new THREE.CylinderGeometry(STICK_RADIUS, STICK_RADIUS, 1, 16);
                adjData.forEach(bond => {
                    const iA = (bond.A || 0) - 1, iB = (bond.B || 0) - 1;
                    if (iA < 0 || iB < 0 || iA >= sxyzData.length || iB >= sxyzData.length) return;
                    const sA = String(sxyzData[iA].Symbol).trim().toUpperCase(), sB = String(sxyzData[iB].Symbol).trim().toUpperCase();
                    if (!showH && (sA === 'H' || sB === 'H')) return;
                    const cA = ATOM_COLORS[sA] || 0xCCCCCC, cB = ATOM_COLORS[sB] || 0xCCCCCC;
                    const posA = new THREE.Vector3(sxyzData[iA].X, sxyzData[iA].Y, sxyzData[iA].Z);
                    const posB = new THREE.Vector3(sxyzData[iB].X, sxyzData[iB].Y, sxyzData[iB].Z);
                    const halfDist = posA.distanceTo(posB) / 2;
                    const dir = new THREE.Vector3().subVectors(posB, posA).normalize();
                    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                    ['A', 'B'].forEach(side => {
                        const mat = new THREE.MeshStandardMaterial({ color: side === 'A' ? cA : cB, emissive: 0x0, metalness: 0.1, roughness: 0.8 });
                        const mesh = new THREE.Mesh(bondGeom, mat);
                        mesh.scale.set(1, halfDist, 1);
                        mesh.position.copy(side === 'A' ? posA : posB).addScaledVector(dir, side === 'A' ? halfDist / 2 : -halfDist / 2);
                        mesh.quaternion.copy(quat);
                        mesh.userData = { isBond: true, atomAIndex: iA + 1, atomBIndex: iB + 1, atomSide: side };
                        bondMeshes.push(mesh);
                        moleculeGroup.add(mesh);
                    });
                });
            }

            function centerAndZoom(sxyzData) {
                if (!moleculeGroup || sxyzData.length === 0) return;
                const box = new THREE.Box3().setFromObject(moleculeGroup);
                const center = new THREE.Vector3();
                box.getCenter(center);
                moleculeGroup.position.sub(center);
                const size = new THREE.Vector3();
                box.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);

                // 修改：使用较小的FOV重新计算相机距离，增加距离系数从1.5到2.2
                let camDist = Math.abs(maxDim / 2 / Math.tan(camera.fov * (Math.PI / 180) / 2)) * 2.2;
                controls.target.set(0, 0, 0);
                const d = camDist / Math.sqrt(3);
                camera.position.set(d, d, d).multiplyScalar(1.7);
                camera.lookAt(controls.target);
                controls.update();
            }

            // 添加从JSON直接加载数据的函数
            function loadJsonData(jsonData, renderType = 'ball_stick') {
                console.log('加载JSON数据:', jsonData, '渲染类型:', renderType);

                try {
                    const smiles = jsonData.SMILES || '--';
                    const smilesElement = document.getElementById('highlight-smiles');
                    if (smilesElement) {
                        smilesElement.textContent = smiles;
                    }
                    // 将SXYZ格式转换为CSV格式
                    // jsonData.SXYZ格式: [["C", 0.0, 0.0, 0.0], ...]
                    // 需要转换为: [{Symbol: "C", X: 0.0, Y: 0.0, Z: 0.0}, ...]
                    const convertedSXYZ = jsonData.SXYZ.map((item, index) => ({
                        Symbol: item[0],
                        X: parseFloat(item[1]),
                        Y: parseFloat(item[2]),
                        Z: parseFloat(item[3])
                    }));

                    // jsonData.ADJ_AB格式: [[1, 2, "-"], [1, 3, "="], ...]
                    // 需要转换为: [{A: 1, B: 2, BondType: "-"}, ...]
                    const convertedADJ = jsonData.ADJ_AB.map(item => ({
                        A: parseInt(item[0]),
                        B: parseInt(item[1]),
                        BondType: item[2] || "-"  // 如果没有指定键型，默认为单键
                    }));

                    console.log('转换后的SXYZ数据:', convertedSXYZ);
                    console.log('转换后的ADJ数据:', convertedADJ);

                    // 保存数据
                    sxyzData = convertedSXYZ;
                    adjData = convertedADJ;

                    // 使用传入的渲染类型
                    currentRenderType = renderType;
                    const status = document.getElementById('status-message');
                    if (status) {
                        status.textContent = '正在渲染3D结构...';
                    }

                    // 调用渲染函数
                    drawMolecule(renderType, sxyzData, adjData);
                    if (status) {
                        const modelName = renderType === 'stick' ? '棒状模型' : '球棍模型';
                        status.textContent = `3D结构已渲染 (${modelName})`;
                    }

                } catch (error) {
                    console.error('加载JSON数据失败:', error);
                    const status = document.getElementById('status-message');
                    if (status) {
                        status.textContent = '错误: ' + error.message;
                    }
                }
            }

            // 从文件加载和绘制
            async function loadAndDraw(renderType) {
                const status = document.getElementById('status-message');
                status.textContent = "正在加载...";

                try {
                    // 如果已经有数据，直接重新渲染
                    if (sxyzData && adjData) {
                        console.log('使用已加载的数据重新渲染:', renderType);
                        currentRenderType = renderType;
                        drawMolecule(renderType, sxyzData, adjData);
                        const modelName = renderType === 'stick' ? '棒状模型' : '球棍模型';
                        status.textContent = `3D结构已渲染 (${modelName})`;
                        return;
                    }

                    // 检查是否有文件选择
                    const fileInput = document.getElementById('json3d-file');
                    if (!fileInput.files.length) {
                        throw new Error('请先选择3d.json文件或使用左侧转换功能');
                    }

                    // 读取JSON文件
                    const file = fileInput.files[0];
                    const text = await file.text();
                    const jsonData = JSON.parse(text);

                    console.log('从文件加载的JSON数据:', jsonData);

                    // 使用相同的加载函数，传入渲染类型
                    loadJsonData(jsonData, renderType);

                } catch (error) {
                    status.textContent = `错误: ${error.message}`;
                    console.error(error);
                }
            }

            init();
            d3Container.querySelector('#status-message').textContent = "等待从左侧画布转换数据...";

            // 暴露公共接口
            return {
                loadJsonData: loadJsonData,
                loadAndDraw: loadAndDraw,
                setLightPreset: setLightPreset,
                exportView: exportView,
                onWindowResize: onWindowResize,
                controls: controls
            };
        })();
    </script>
</body>
</html>