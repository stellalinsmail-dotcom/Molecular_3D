<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Molecular3D-MMFFOpt</title>

    <!-- 全局和布局样式 -->
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #20232A; /* 使用Draw.html的深色背景作为全局背景 */
        }

        #main-container {
            display: flex;
            height: 100%;
            width: 100%;
        }

        #draw-container, #d3-container {
            height: 100%;
            position: relative;
            overflow: hidden; /* 隐藏内部溢出 */

        }

        #draw-container {
            width: 50%;
            min-width: 300px; /* 最小宽度 */
            display: flex;
            flex-direction: row;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #d3-container {
            flex: 1; /* 占据剩余空间 */
            min-width: 400px; /* 最小宽度 */
        }

        #resizer {
            width: 8px;
            height: 100%;
            background-color: #3C424F;
            cursor: col-resize;
            flex-shrink: 0;
            z-index: 200;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #conversion-controls {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 201;
            /* 新增：背景装饰 */
            padding: 15px 10px;
            background: rgb(60, 66, 79);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #convert-btn {
            writing-mode: vertical-rl;
            text-orientation: upright;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 8px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            letter-spacing: 2px;

            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #convert-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }

        #convert-btn:active {
            transform: scale(0.95);
        }

        #convert-btn:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #server-status {
            writing-mode: vertical-rl;
            text-orientation: upright;
            background: rgba(40, 44, 52, 0.9);
            color: #ddd;
            padding: 10px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #555;
            letter-spacing: 1px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #server-status.running {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
            color: #4CAF50;
        }

        #server-status.error {
            background: rgba(200, 67, 54, 0.2);
            border-color: #f44336;
            color: #f44336;
        }

        #server-status.converting {
            background: rgba(255, 193, 7, 0.2);
            border-color: #FFC107;
            color: #FFC107;
        }
    </style>

    <!-- Draw.html 的样式 (已用 #draw-container 作用域限定) -->
    <style>
        #draw-container {
            --bg-dark: #20232A;
            --toolbar-bg: rgba(40, 44, 52, 0.85); /* 修正#2: 增加透明度 */
            --canvas-bg: #FFFFFF;
            --border-color: #3C424F;
            --text-color-light: #F8F8F8;
            --active-bg: #3C424F;
            --hover-bg: #4A515F;
            --atom-color: #61AFEF;
            --bond-color: #98C379;
            --mode-color: #C678DD;
            --delete-color: #E06C75;
            --export-color: #FFD700;
            /* 修正#2: 动态颜色变量 */
            --draw-atom-C: #282C34;
            --draw-atom-H: #A9A9A9;
            --draw-atom-O: #87CEFA;
            --draw-atom-N: #FFD700;
            --draw-atom-S: #FFB6C1;
            --draw-bond-color: #282C34;
        }

            #draw-container #toolbar {
                width: 120px;
                background: var(--toolbar-bg);
                backdrop-filter: blur(5px); /* 修正#2: 毛玻璃效果 */
                padding: 10px 10px;
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                gap: 10px;
                overflow-y: auto;
                box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
                flex-shrink: 0;
            }

            #draw-container .button-group {
                display: flex;
                flex-direction: column;
                gap: 5px;
                padding-bottom: 5px;
            }

            #draw-container .divider {
                height: 1px;
                background: var(--border-color);
                margin: 1px 0;
            }

            #draw-container .section-title {
                font-size: 10px;
                color: #9DA5B4;
                text-transform: uppercase;
                margin-bottom: 5px;
                text-align: center;
            }

            #draw-container button {
                width: 100%;
                padding: 5px 3px;
                font-size: 12px;
                line-height: 1.2;
                background: transparent;
                border: 1px solid var(--border-color);
                color: var(--text-color-light);
                cursor: pointer;
                border-radius: 4px;
                transition: all 0.2s ease-in-out;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                display: flex;
                align-items: center;
                justify-content: center;
            }

                #draw-container button:hover {
                    background: var(--hover-bg);
                    border-color: var(--hover-bg);
                    color: var(--text-color-light);
                }

                #draw-container button.active {
                    background: var(--active-bg);
                    border-color: var(--active-bg);
                    box-shadow: 0 0 5px rgba(97, 175, 239, 0.5);
                }

            #draw-container #draw-bg-controls {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-top: 5px;
            }

            #draw-container #draw-bg-picker-container {
                width: 25px;
                height: 18px;
                border: 1px solid var(--text-color-light);
                border-radius: 4px;
                overflow: hidden;
                position: relative;
                cursor: pointer;
            }

            #draw-container #draw-bg-picker {
                width: 150%;
                height: 150%;
                position: absolute;
                top: -25%;
                left: -25%;
                padding: 0;
                border: none;
                cursor: pointer;
                opacity: 0;
            }

            #draw-container .draw-color-swatch {
                width: 16px;
                height: 16px;
                border: 1px solid var(--text-color-light);
                cursor: pointer;
                border-radius: 50%;
                transition: transform 0.1s;
            }

                #draw-container .draw-color-swatch:hover {
                    transform: scale(1.1);
                }

            #draw-container .atom-btn.active {
                color: var(--atom-color);
                border-color: var(--atom-color);
            }

            #draw-container .bond-btn.active {
                color: var(--bond-color);
                border-color: var(--bond-color);
            }

            #draw-container .mode-btn.active {
                color: var(--mode-color);
                border-color: var(--mode-color);
            }

            #draw-container #exportPngBtn {
                background: var(--export-color);
                border-color: var(--export-color);
                color: #282C34;
                font-weight: bold;
                margin-top: 10px;
            }

                #draw-container #exportPngBtn:hover {
                    background: #D4AF37;
                    border-color: #D4AF37;
                }

            #draw-container #deleteBtn {
                background: var(--delete-color);
                border-color: var(--delete-color);
                font-weight: bold;
                margin-top: 5px;
            }

                #draw-container #deleteBtn:hover {
                    background: #B94451;
                    border-color: #B94451;
                }


            #draw-container #canvas-wrapper {
                flex: 1;
                background: var(--canvas-bg);
                overflow: hidden;
            }

            #draw-container svg {
                width: 100%;
                height: 100%;
                cursor: crosshair;
                background-color: var(--canvas-bg); /* Use variable for SVG background */
            }

                #draw-container svg .selectable-atom {
                    stroke: transparent;
                    fill: transparent;
                    stroke-width: 2;
                    cursor: pointer;
                }

                    #draw-container svg .selectable-atom.selected {
                        stroke: #FFD700;
                        stroke-width: 3;
                        fill: rgba(255, 255, 0, 0.1);
                    }

                #draw-container svg .selectable-bond {
                    stroke: transparent;
                    stroke-width: 10;
                    cursor: pointer;
                }

                    #draw-container svg .selectable-bond.selected {
                        stroke: #FFD700;
                    }

                #draw-container svg text {
                    user-select: none;
                    pointer-events: none;
                }

            #draw-container .wedge-icon {
                width: 16px;
                height: 10px;
                overflow: visible;
                background-color: var(--toolbar-bg);
               /* 确保SVG图标颜色跟随按钮文本颜色 */
            }
                #draw-container.wedge-icon.active {
                    background-color: var(--active-bg)

                }
                #draw-container.wedge-icon:hover {
                    background-color: var(--hover-bg);
                }

            #draw-container #selectionRect {
                fill: rgba(100, 150, 255, 0.1);
                stroke: #61AFEF;
                stroke-width: 1;
                stroke-dasharray: 4, 2;
            }
    </style>

    <!-- 3D_V3.html 的样式 -->
    <style>
        #d3-container {
            --color-load-light: #FFC09F;
            --color-light-light: #F0B7C6;
            --color-params-light: #B6E0C7;
            --color-export-light: #B0D6F5;
            --color-text-dark: #DDDDDD;
            --color-load-dark: #D48060;
            --color-light-dark: #C47A9A;
            --color-params-dark: #86A890;
            --color-export-dark: #7096B0;
            --color-text-light: #333333;
            --current-text-color: var(--color-text-light);
            --current-load-color: var(--color-load-dark);
            --current-light-color: var(--color-light-dark);
            --current-params-color: var(--color-params-dark);
            --current-export-color: var(--color-export-dark);
            --current-toggle-active: var(--color-params-dark);
            --axis-x-color: #D62828;
            --axis-y-color: #008000;
            --axis-z-color: #0000FF;
            --axis-text-color: #FFFFFF;
        }

        #d3-container {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #FFFFFF;
        }

            #d3-container canvas {
                display: block;
            }

            #d3-container #controls-container-wrapper {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 100;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                line-height: 1.2;
                transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            #d3-container .control-panel {
                padding: 10px;
                margin-bottom: 10px;
                background: rgba(240, 240, 240, 0.35);
                backdrop-filter: blur(5px);
                border-radius: 12px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.15);
                width: 180px;
                box-sizing: border-box;
                color: var(--current-text-color);
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            }

                #d3-container .control-panel h3 {
                    margin-top: 0;
                    margin-bottom: 8px;
                    font-size: 15px;
                    font-weight: 500;
                    color: var(--current-load-color);
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    padding-bottom: 4px;
                    text-shadow: -0.1px -0.1px #000,0.1px 0.1px #ccc;
                }

            #d3-container .control-group {
                margin-bottom: 8px;
            }

                #d3-container .control-group label {
                    color: var(--current-text-color);
                    font-size: 13px;
                    margin-bottom: 2px;
                    display: block;
                }

            /* 修正#3: 隐藏原生input，用label美化 */
            #d3-container input[type="file"] {
                display: none;
            }

            #d3-container .file-upload-label {
                display: block;
                padding: 8px 12px;
                background-color: var(--current-load-color);
                color: #333;
                border-radius: 8px;
                cursor: pointer;
                text-align: center;
                font-weight: 600;
                margin-bottom: 8px;
                transition: background-color 0.2s;
            }

                #d3-container .file-upload-label:hover {
                    opacity: 0.9;
                }

            #d3-container #status-message {
                font-size: 13px;
                margin-top: 5px;
                margin-bottom: 0;
                line-height: 1.2;
                color: var(--current-load-color);
            }

            #d3-container button {
                padding: 5px 10px;
                cursor: pointer;
                box-sizing: border-box;
                margin-top: 5px;
                border: none;
                border-radius: 8px;
                font-weight: 600;
                transition: all 0.2s;
                box-shadow: 0 3px 0 0 rgba(0, 0, 0, 0.2);
                color: #333;
            }

                #d3-container button:hover {
                    opacity: 0.9;
                    transform: translateY(-1px);
                    box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.2);
                }

                #d3-container button:active {
                    transform: translateY(2px);
                    box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.2);
                }

            #d3-container #render-buttons {
                display: flex;
                gap: 6px;
                margin-top: 8px;
            }

                #d3-container #render-buttons button {
                    width: 50%;
                    background-color: var(--current-load-color);
                }

            #d3-container #light-presets {
                display: flex;
                gap: 6px;
                margin-top: 8px;
            }

                #d3-container #light-presets button {
                    width: 50%;
                    background-color: var(--current-light-color);
                }

            #d3-container #export-controls-panel button {
                width: 100%;
                background-color: var(--current-export-color);
            }

            #d3-container .light-control-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 5px;
                color: var(--current-text-color);
            }

            #d3-container #hydrogen-toggle-group {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
            }

                #d3-container #hydrogen-toggle-group label:first-child {
                    display: inline;
                    margin-bottom: 0;
                }

            #d3-container .light-control-row input[type="range"] {
                width: 100%;
                height: 4px;
                -webkit-appearance: none;
                background: rgba(255, 255, 255, 0.5);
                border: 1px solid rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                margin: 5px 0;
                box-shadow: none;
            }

                #d3-container .light-control-row input[type="range"]::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: var(--current-export-color);
                    cursor: pointer;
                    box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
                }

            #d3-container #background-picker-group-wrapper {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            #d3-container #background-color-picker-container {
                width: 25px;
                height: 18px;
                border: 1px solid var(--current-text-color);
                border-radius: 4px;
                margin-left: 5px;
                overflow: hidden;
                position: relative;
                cursor: pointer;
                transition: border-color 0.3s;
            }

            #d3-container #background-color-picker {
                width: 150%;
                height: 150%;
                position: absolute;
                top: -25%;
                left: -25%;
                padding: 0;
                border: none;
                cursor: pointer;
                opacity: 0;
            }

            #d3-container #background-picker-group {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            #d3-container .color-swatch {
                width: 20px;
                height: 20px;
                border: 1px solid var(--current-text-color);
                cursor: pointer;
                border-radius: 50%;
                transition: transform 0.1s;
            }

                #d3-container .color-swatch:hover {
                    transform: scale(1.1);
                    box-shadow: 0 0 5px var(--current-text-color);
                }

            #d3-container #highlight-info {
                position: absolute;
                bottom: 40px;
                left: 10px;
                z-index: 100;
                font-family: Arial, sans-serif;
                font-size: 14px;
                line-height: 1.4;
                padding: 5px;
                background: none;
                color: #FFFFFF;
                text-shadow: none;
            }

            #d3-container #toggle-button-wrapper {
                position: absolute;
                bottom: 10px;
                left: 10px;
                z-index: 101;
                font-family: Arial, sans-serif;
                font-size: 14px;
                display: flex;
                align-items: center;
                color: #FFFFFF;
                text-shadow: none;
            }

            #d3-container #controls-label {
                margin-right: 8px;
                white-space: nowrap;
            }

            #d3-container .toggle-switch {
                position: relative;
                display: inline-block;
                width: 64px;
                height: 20px;
            }

                #d3-container .toggle-switch input {
                    opacity: 0;
                    width: 0;
                    height: 0;
                }

            #d3-container .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #444;
                transition: background-color .4s;
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0 6px;
                color: #E0E0E0;
                font-weight: 500;
                font-size: 11px;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4);
                text-shadow: none;
                user-select: none;

                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            }

                #d3-container .slider:before {
                    position: absolute;
                    content: "";
                    height: 14px;
                    width: 14px;
                    left: 3px;
                    bottom: 3px;
                    background-color: #FFFFFF;
                    transition: transform .4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                    border-radius: 50%;
                    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
                }

            #d3-container .toggle-switch input:checked + .slider {
                background-color: var(--current-toggle-active);
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
                color: #333;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider:before {
                transform: translateX(41px);
            }

            #d3-container .toggle-switch input:checked + .slider:before {
                transform: translateX(0);
            }

            #d3-container .slider-text-off {
                position: absolute;
                left: 6px;
                opacity: 1;
                transition: opacity .4s;
            }

            #d3-container .slider-text-on {
                position: absolute;
                right: 6px;
                opacity: 0;
                transition: opacity .4s;
            }

            #d3-container .toggle-switch input:checked + .slider .slider-text-off {
                opacity: 0;
            }

            #d3-container .toggle-switch input:checked + .slider .slider-text-on {
                opacity: 1;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider .slider-text-off {
                opacity: 1;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider .slider-text-on {
                opacity: 0;
            }

            #d3-container #axis-renderer-container {
                position: absolute;
                top: 10px;
                left: 10px;
                width: 80px;
                height: 80px;
                z-index: 100;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            }

                #d3-container #axis-renderer-container canvas {
                    position: absolute;
                    top: 0;
                    left: 0;
                }
    </style>
</head>
<body>

    <div id="main-container">
        <!-- 左侧：Draw.html 内容 -->
        <div id="draw-container">
            <div id="toolbar">
                <div class="button-group">
                    <div class="section-title">原子 (Atom)</div>
                    <button data-tool="C" class="atom-btn active">C</button>
                    <button data-tool="H" class="atom-btn">H</button>
                    <button data-tool="O" class="atom-btn">O</button>
                    <button data-tool="N" class="atom-btn">N</button>
                    <button data-tool="S" class="atom-btn">S</button>
                </div>
                <div class="divider"></div>
                <div class="button-group">
                    <div class="section-title">键 (Bond)</div>
                    <button data-bond="single" class="bond-btn active">单键</button>
                    <button data-bond="double" class="bond-btn">双键</button>
                    <button data-bond="triple" class="bond-btn">三键</button>

                    <button data-bond="wedge-up" class="bond-btn" id="wedgeUpBtn">
                        <svg class="wedge-icon" viewBox="0 0 16 10">
                            <polygon points="0,5 16,10 16,0" fill="#fff" />
                        </svg>
                    </button>
                    <button data-bond="wedge-down" class="bond-btn" id="wedgeDownBtn">
                        <svg class="wedge-icon" viewBox="0 0 16 10">
                            <g fill="#fff">
                                <polygon points="0,5 4,7 4,3" />
                                <polygon points="6,6 10,8 10,2 6,4" />
                                <polygon points="12,2 12,8 16,10 16,0" />
                            </g>
                        </svg>
                    </button>
                </div>
                <div class="divider"></div>
                <div class="button-group">
                    <div class="section-title">功能 (Tool)</div>
                    <button id="drawBtn" class="mode-btn active">✏️ 构造</button>
                    <button id="moveBtn" class="mode-btn">🤚 移动</button>
                    <button id="lassoBtn" class="mode-btn">🔲 套索</button>

                    <!-- 修正#1: 新增背景选择栏 -->
                    <div class="section-title" style="margin-top: 10px;">背景 (Background)</div>
                    <div id="draw-bg-controls">
                        <div id="draw-bg-picker-container" style="background-color: #FFFFFF;">
                            <input type="color" id="draw-bg-picker" value="#FFFFFF">
                        </div>
                        <div class="draw-color-swatch" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                        <div class="draw-color-swatch" style="background-color: #888888;" data-color="#888888"></div>
                        <div class="draw-color-swatch" style="background-color: #000000;" data-color="#000000"></div>
                    </div>

                    <button id="exportPngBtn">📷 导出 PNG</button>

                    <button id="deleteBtn">🗑️ 删除</button>
                </div>
            </div>
            <div id="canvas-wrapper">
                <svg id="draw-svg"></svg>
            </div>
        </div>

        <!-- 拖动条 -->
        <div id="resizer">
            <div id="conversion-controls">
                <button id="convert-btn">3D构象生成</button>
                <div id="server-status">未连接</div>
            </div>
        </div>

        <!-- 右侧：3D_V3.html 内容 (HTML调整为单一文件输入) -->
        <div id="d3-container">
            <div id="axis-renderer-container"></div>
            <div id="highlight-info">
                <div>原子符号：<span id="highlight-symbol">无</span></div>
                <div>原子编号：<span id="highlight-index">--</span></div>
                <div>原子颜色：<span id="highlight-color">#--</span></div>
                <div>原子坐标：<span id="highlight-coords">----</span></div>
            </div>
            <div id="toggle-button-wrapper">
                <span id="controls-label">功能区:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="controls-toggle" checked>
                    <span class="slider">
                        <span class="slider-text-on">开</span>
                        <span class="slider-text-off">关</span>
                    </span>
                </label>
            </div>
            <div id="controls-container-wrapper">
                <div id="file-input-panel" class="control-panel">
                    <h3>模型选择</h3>
                    <div id="render-buttons">
                        <button class="load-button" onclick="d3App.loadAndDraw('ball_stick')">球棍</button>
                        <button class="load-button" onclick="d3App.loadAndDraw('stick')">棒状</button>
                    </div>
                    <p id="status-message">等待从左侧画布转换数据...</p>
                </div>
                <div id="light-controls-panel" class="control-panel">
                    <h3>光照调节</h3>
                    <div class="control-group">
                        <label>环境光强度 (<span id="ambient-value">4.0</span>)</label>
                        <div class="light-control-row">
                            <input type="range" id="ambient-light-range" min="0.0" max="5.0" step="0.1" value="4.0">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>点光源强度 (<span id="directional-value">0.0</span>)</label>
                        <div class="light-control-row">
                            <input type="range" id="directional-light-range" min="0.0" max="2.0" step="0.1" value="0.0">
                        </div>
                    </div>
                    <div id="light-presets">
                        <button class="light-button" onclick="d3App.setLightPreset('clear')">清透</button>
                        <button class="light-button" onclick="d3App.setLightPreset('3d')">立体</button>
                    </div>
                </div>
                <div id="params-controls-panel" class="control-panel">
                    <h3>参数修改</h3>
                    <div class="control-group">
                        <label>背景颜色</label>
                        <div id="background-picker-group-wrapper">
                            <div id="background-color-picker-container" style="background-color: #FFFFFF;">
                                <input type="color" id="background-color-picker" value="#FFFFFF">
                            </div>
                            <div id="background-picker-group">
                                <div class="color-swatch" style="background-color: #000000;" data-color="#000000"></div>
                                <div class="color-swatch" style="background-color: #888888;" data-color="#888888"></div>
                                <div class="color-swatch" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                            </div>
                        </div>
                    </div>
                    <div class="control-group" id="hydrogen-toggle-group">
                        <label>显示H</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="show-hydrogen" checked>
                            <span class="slider">
                                <span class="slider-text-on">是</span>
                                <span class="slider-text-off">否</span>
                            </span>
                        </label>
                    </div>
                </div>
                <div id="export-controls-panel" class="control-panel">
                    <h3>图片导出</h3>
                    <button class="export-button" onclick="d3App.exportView('png')">导出 PNG (无背景)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 依赖库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvg/3.0.10/canvg.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

    <!-- 拖动条脚本 -->
    <script>
        // Socket通信管理
        const socketManager = {
            serverUrl: 'http://localhost:8765',
            isConnected: false,

            updateStatus: function (status, message) {
                const statusEl = document.getElementById('server-status');
                const convertBtn = document.getElementById('convert-btn');

                statusEl.className = status;
                statusEl.textContent = message;

                if (status === 'running') {
                    convertBtn.disabled = false;
                } else if (status === 'converting') {
                    convertBtn.disabled = true;
                } else {
                    convertBtn.disabled = true;
                }
            },

            checkConnection: async function () {
                try {
                    const response = await fetch(this.serverUrl + '/status', {
                        method: 'GET',
                        signal: AbortSignal.timeout(1000)
                    });

                    if (response.ok) {
                        this.updateStatus('running', '服务运行中');
                        this.isConnected = true;
                        return true;
                    }
                } catch (error) {
                    this.updateStatus('error', '未连接');
                    this.isConnected = false;
                    return false;
                }
            },

            sendData: async function (jsonData) {
                this.updateStatus('converting', '转换中...');

                try {
                    const response = await fetch(this.serverUrl + '/convert', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: jsonData,
                        signal: AbortSignal.timeout(300000) // 300秒超时
                    });

                    if (!response.ok) {
                        throw new Error('服务器响应错误: ' + response.status);
                    }

                    const result = await response.json();
                    this.updateStatus('running', '服务运行中');
                    return result;
                } catch (error) {
                    console.error('发送数据失败:', error);
                    this.updateStatus('error', '转换失败');

                    let errorMsg = '转换失败：' + error.message + '\n\n请确认：\n';
                    errorMsg += '1. C++程序正在运行\n';
                    errorMsg += '2. 端口8765未被占用\n';
                    errorMsg += '3. 防火墙允许本地连接';
                    alert(errorMsg);
                    return null;
                }
            }
        };

        // 页面加载时检查连接
        window.addEventListener('DOMContentLoaded', function () {
            // 延迟1秒后开始检查连接，给C++程序启动时间
            setTimeout(() => {
                socketManager.checkConnection();
                // 每5秒检查一次连接状态
                setInterval(() => {
                    socketManager.checkConnection();
                }, 5000);
            }, 1000);
        });

        // 转换按钮事件
        document.getElementById('convert-btn').addEventListener('click', async function () {
            console.log('转换按钮被点击');

            // 先检查连接
            const connected = await socketManager.checkConnection();
            if (!connected) {
                alert('无法连接到C++程序！\n\n请确保：\n1. Main_MMFF94.exe正在运行\n2. 程序显示"Socket服务器已启动"');
                return;
            }

            // 从Draw部分获取分子数据
            if (!window.drawApp || !window.drawApp.getJsonData) {
                alert('画布数据不可用！');
                return;
            }

            const drawData = window.drawApp.getJsonData();
            if (!drawData || !drawData.Atom || drawData.Atom.length === 0) {
                alert('画布为空，无法转换！\n\n请先在左侧画布中绘制分子结构。');
                return;
            }

            console.log('发送数据:', drawData);

            // 发送到C++程序
            const result = await socketManager.sendData(JSON.stringify(drawData));

            if (result && result.status === 'success' && result.data) {
                console.log('接收到3D数据:', result.data);

                // 将数据传递给3D部分
                if (window.d3App && window.d3App.loadJsonData) {
                    window.d3App.loadJsonData(result.data);
                    alert('转换成功！\n\n3D结构已加载到右侧视图。');
                } else {
                    console.error('3D模块未就绪');
                    alert('3D模块加载失败，请刷新页面重试。');
                }
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            const resizer = document.getElementById('resizer');
            const drawContainer = document.getElementById('draw-container');
            const d3Container = document.getElementById('d3-container');
            let isResizing = false;
            resizer.addEventListener('mousedown', (e) => {
                // 检查是否点击在按钮或状态框上
                if (e.target.id === 'convert-btn' || e.target.id === 'server-status' ||
                    e.target.closest('#conversion-controls')) {
                    return;
                }

                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                if (window.d3App && window.d3App.controls) {
                    window.d3App.controls.enabled = false;
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const mainRect = document.getElementById('main-container').getBoundingClientRect();
                let newDrawWidth = e.clientX - mainRect.left;
                const minDrawWidth = parseInt(getComputedStyle(drawContainer).minWidth, 10);
                const minD3Width = parseInt(getComputedStyle(d3Container).minWidth, 10);
                if (newDrawWidth < minDrawWidth) newDrawWidth = minDrawWidth;
                if (mainRect.width - newDrawWidth - resizer.offsetWidth < minD3Width) {
                    newDrawWidth = mainRect.width - minD3Width - resizer.offsetWidth;
                }
                drawContainer.style.width = newDrawWidth + 'px';
                if (window.d3App && typeof window.d3App.onWindowResize === 'function') {
                    window.d3App.onWindowResize();
                }
            });
            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.body.style.userSelect = 'auto';
                if (window.d3App && window.d3App.controls) {
                    window.d3App.controls.enabled = true;
                }
            });
        });
    </script>

    <!-- Draw.html 脚本 (已修改：增加 JSON 导出并修复 PNG 导出) -->
    <script>
        (function () {
            function getLuminance(hexColor) {
                const rgb = parseInt(hexColor.slice(1), 16);
                const r = (rgb >> 16) & 0xff;
                const g = (rgb >> 8) & 0xff;
                const b = (rgb >> 0) & 0xff;
                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            }

            function updateDrawTheme(hexColor) {
                const rootStyle = document.getElementById('draw-container').style;
                const isLight = getLuminance(hexColor) > 128;
                rootStyle.setProperty('--canvas-bg', hexColor);
                if (isLight) {
                    rootStyle.setProperty('--draw-atom-C', '#282C34');
                    rootStyle.setProperty('--draw-atom-H', '#A9A9A9');
                    rootStyle.setProperty('--draw-atom-O', '#7CBDE6');
                    rootStyle.setProperty('--draw-atom-N', '#DAA520');
                    rootStyle.setProperty('--draw-atom-S', '#FFB6C1');
                    rootStyle.setProperty('--draw-bond-color', '#282C34');
                } else {
                    rootStyle.setProperty('--draw-atom-C', '#CCCCCC');
                    rootStyle.setProperty('--draw-atom-H', '#A9A9A9');
                    rootStyle.setProperty('--draw-atom-O', '#87CEFA');
                    rootStyle.setProperty('--draw-atom-N', '#FFD700');
                    rootStyle.setProperty('--draw-atom-S', '#DB9DA6');
                    rootStyle.setProperty('--draw-bond-color', '#CCCCCC');
                }
                draw();
            }

            const getCssColor = (elem) => {
                const style = getComputedStyle(document.getElementById('draw-container'));
                if (['C', 'H', 'O', 'N', 'S'].includes(elem)) {
                    return style.getPropertyValue(`--draw-atom-${elem}`).trim();
                }
                return style.getPropertyValue('--draw-bond-color').trim();
            };

            let atoms = [];
            let bonds = [];
            let selectedAtoms = new Set();
            let selectedBonds = new Set();
            let currentTool = 'C';
            let currentBond = 'single';
            let nextAtomId = 1;
            let nextBondId = 0;
            let mode = 'draw';
            let dragStartPos = { x: 0, y: 0 };
            let isDraggingAtom = false;
            let dragTargetId = null;
            let dragStartOffset = { x: 0, y: 0 };
            let isDraggingSelection = false;

            const svg = document.getElementById('draw-svg');
            let isSelecting = false;
            let startX = 0, startY = 0;
            let selectionRect;
            let selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };

            const ATOM_RADIUS = 10;
            const ATOM_FONT_SIZE = '14px';
            const BOND_STROKE_WIDTH = 2;
            const BOND_END_OFFSET = 10;
            const BOND_TYPE_OFFSET = 3;
            const WEDGE_WIDTH = 8;
            const HOVER_COLOR = 'rgba(97, 175, 239, 0.5)';
            const CLICK_THRESHOLD = 5;

            // 暴露获取JSON数据的接口
            window.drawApp = {
                getJsonData: function () {
                    if (!atoms || atoms.length === 0) {
                        return null;
                    }
                    // 按照cpp中AnalysisJsonFile期望的格式生成数据
                    const atomArr = atoms.slice().sort((a, b) => a.id - b.id).map(a => [a.id, a.elem]);
                    const adjArr = bonds.map(b => [b.a1, b.a2, b.type]);
                    return { "Atom": atomArr, "Adj": adjArr };
                }
            };

            function draw() {
                svg.innerHTML = '';
                const atomMap = new Map(atoms.map(a => [a.id, a]));
                const bondCount = atoms.reduce((acc, atom) => {
                    acc[atom.id] = bonds.filter(b => b.a1 === atom.id || b.a2 === atom.id).length;
                    return acc;
                }, {});

                const bondColor = getCssColor('bond');

                const createLine = (x1, y1, x2, y2, strokeWidth = BOND_STROKE_WIDTH, strokeColor = bondColor) => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                    line.setAttribute('stroke', strokeColor);
                    line.setAttribute('stroke-width', strokeWidth);
                    line.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(line);
                };

                const createWedge = (x1, y1, x2, y2, type, fillColor = bondColor) => {
                    const dx = x2 - x1, dy = y2 - y1;
                    const dist = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);
                    const perpAngle = angle + Math.PI / 2;
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                    if (type === 'wedge-up') {
                        const offset = WEDGE_WIDTH / 2;
                        const endOffX = offset * Math.cos(perpAngle), endOffY = offset * Math.sin(perpAngle);
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', `${x1},${y1} ${x2 + endOffX},${y2 + endOffY} ${x2 - endOffX},${y2 - endOffY}`);
                        polygon.setAttribute('fill', fillColor);
                        g.appendChild(polygon);
                    } else if (type === 'wedge-down') {
                        const dashLength = 3, dashGap = 1.5;
                        for (let currentDist = 0; currentDist < dist; currentDist += dashLength + dashGap) {
                            const startRatio = currentDist / dist, endRatio = Math.min(1, (currentDist + dashLength) / dist);
                            const startWidth = WEDGE_WIDTH * (1 - startRatio), endWidth = WEDGE_WIDTH * (1 - endRatio);
                            const p1 = { x: (startWidth / 2) * Math.cos(perpAngle), y: (startWidth / 2) * Math.sin(perpAngle) };
                            const p2 = { x: (endWidth / 2) * Math.cos(perpAngle), y: (endWidth / 2) * Math.sin(perpAngle) };
                            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            polygon.setAttribute('points', `${x2 - startRatio * dx + p1.x},${y2 - startRatio * dy + p1.y} ${x2 - endRatio * dx + p2.x},${y2 - endRatio * dy + p2.y} ${x2 - endRatio * dx - p2.x},${y2 - endRatio * dy - p2.y} ${x2 - startRatio * dx - p1.x},${y2 - startRatio * dy - p1.y}`);
                            polygon.setAttribute('fill', fillColor);
                            g.appendChild(polygon);
                        }
                    }
                    svg.appendChild(g);
                };

                bonds.forEach(b => {
                    const a1 = atomMap.get(b.a1), a2 = atomMap.get(b.a2);
                    if (!a1 || !a2) return;
                    const dx = a2.x - a1.x, dy = a2.y - a1.y, angle = Math.atan2(dy, dx);
                    let startOffset = a1.elem !== 'C' ? BOND_END_OFFSET : 0;
                    let endOffset = a2.elem !== 'C' ? BOND_END_OFFSET : 0;
                    const dist = Math.hypot(dx, dy) - startOffset - endOffset;
                    if (dist <= 0) return;
                    const startX = a1.x + startOffset * Math.cos(angle), startY = a1.y + startOffset * Math.sin(angle);
                    const endX = a2.x - endOffset * Math.cos(angle), endY = a2.y - endOffset * Math.sin(angle);
                    const hotspot = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hotspot.setAttribute('x1', startX); hotspot.setAttribute('y1', startY);
                    hotspot.setAttribute('x2', endX); hotspot.setAttribute('y2', endY);
                    hotspot.setAttribute('class', `selectable-bond${selectedBonds.has(b.id) ? ' selected' : ''}`);
                    hotspot.setAttribute('data-bond-id', b.id);
                    svg.appendChild(hotspot);
                    const strokeColor = selectedBonds.has(b.id) ? '#FFD700' : bondColor;
                    const offset = BOND_TYPE_OFFSET, perpAngle = angle + Math.PI / 2;
                    const offX = offset * Math.cos(perpAngle), offY = offset * Math.sin(perpAngle);
                    if (b.type === 'double') {
                        createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                        createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                    } else if (b.type === 'triple') {
                        createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                        createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                        createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                    } else if (b.type === 'wedge-up' || b.type === 'wedge-down') {
                        createWedge(startX, startY, endX, endY, b.type, strokeColor);
                    } else {
                        createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                    }
                });

                atoms.forEach(a => {
                    const shouldDrawSymbol = !(a.elem === 'C' && bondCount[a.id] > 0);
                    const clickableCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    clickableCircle.setAttribute('cx', a.x); clickableCircle.setAttribute('cy', a.y);
                    clickableCircle.setAttribute('r', ATOM_RADIUS);
                    clickableCircle.setAttribute('class', `selectable-atom${selectedAtoms.has(a.id) ? ' selected' : ''}`);
                    clickableCircle.setAttribute('data-atom-id', a.id);
                    svg.appendChild(clickableCircle);
                    if (shouldDrawSymbol) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', a.x); text.setAttribute('y', a.y);
                        text.setAttribute('text-anchor', 'middle'); text.setAttribute('dominant-baseline', 'middle');
                        text.setAttribute('fill', getCssColor(a.elem));
                        text.setAttribute('font-size', ATOM_FONT_SIZE);
                        text.setAttribute('font-weight', 'bold');
                        text.textContent = a.elem;
                        text.setAttribute('data-atom-id', a.id);
                        svg.appendChild(text);
                    }
                });

                if (isSelecting && selectionRect) svg.appendChild(selectionRect);
            }

            function addAtom(elem, x, y) { atoms.push({ id: nextAtomId++, elem, x, y }); draw(); }
            function addBond(id1, id2) {
                const existing = bonds.find(b => (b.a1 === id1 && b.a2 === id2) || (b.a1 === id2 && b.a2 === id1));
                if (existing) {
                    if (currentBond === 'single') existing.type = existing.type === 'single' ? 'double' : existing.type === 'double' ? 'triple' : 'single';
                    else existing.type = currentBond;
                } else {
                    bonds.push({ id: nextBondId++, a1: id1, a2: id2, type: currentBond });
                }
                draw();
            }
            function extendFrom(atomId, mouseX, mouseY) {
                const parentAtom = atoms.find(a => a.id === atomId);
                if (!parentAtom) return;

                const dx = mouseX - parentAtom.x;
                const dy = mouseY - parentAtom.y;
                let angle = Math.atan2(dy, dx);
                if (angle < 0) {
                    angle += 2 * Math.PI;
                }

                const bondAngles = [
                    0, Math.PI / 6, Math.PI / 3, Math.PI / 2, 2 * Math.PI / 3, 5 * Math.PI / 6, Math.PI,
                    7 * Math.PI / 6, 4 * Math.PI / 3, 3 * Math.PI / 2, 5 * Math.PI / 3, 11 * Math.PI / 6, 2 * Math.PI
                ];

                let closestAngle = bondAngles[0];
                let minDiff = Math.abs(angle - closestAngle);
                for (let i = 1; i < bondAngles.length; i++) {
                    const diff = Math.abs(angle - bondAngles[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestAngle = bondAngles[i];
                    }
                }

                const dist = 40;
                const newX = parentAtom.x + dist * Math.cos(closestAngle);
                const newY = parentAtom.y + dist * Math.sin(closestAngle);

                const overlappingAtom = atoms.find(a =>
                    Math.sqrt(Math.pow(newX - a.x, 2) + Math.pow(newY - a.y, 2)) < ATOM_RADIUS
                );

                if (overlappingAtom) {
                    addBond(parentAtom.id, overlappingAtom.id);
                } else {
                    const newAtomId = nextAtomId;
                    addAtom(currentTool, newX, newY);
                    addBond(parentAtom.id, newAtomId);
                }
            }

            function toggleSelectAtom(atomId) {
                if (selectedAtoms.has(atomId)) {
                    selectedAtoms.delete(atomId);
                } else {
                    selectedAtoms.add(atomId);
                }
                draw();
            }

            function toggleSelectBond(bondId) {
                if (selectedBonds.has(bondId)) {
                    selectedBonds.delete(bondId);
                } else {
                    selectedBonds.add(bondId);
                }
                draw();
            }

            function clearSelection() {
                selectedAtoms.clear();
                selectedBonds.clear();
                if (selectionRect && selectionRect.parentNode) {
                    selectionRect.parentNode.removeChild(selectionRect);
                }
                selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };
                draw();
            }

            function isInsideSelectionBox(x, y) {
                const padding = 5;
                if (selectedAtoms.size === 0) return false;
                if (selectionBox.right - selectionBox.left === 0 || selectionBox.bottom - selectionBox.top === 0) return false;

                return x >= selectionBox.left - padding && x <= selectionBox.right + padding &&
                    y >= selectionBox.top - padding && y <= selectionBox.bottom + padding;
            }

            function getMousePos(e) {
                const rect = svg.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function updateCanvasCursor() {
                svg.classList.remove('move-cursor', 'lasso-cursor');
                if (mode === 'move') {
                    svg.classList.add('move-cursor');
                } else if (mode === 'lasso') {
                    svg.classList.add('lasso-cursor');
                } else {
                    svg.style.cursor = 'crosshair';
                }
            }

            function deleteSelectedElements() {
                const atomsToDelete = new Set(selectedAtoms);
                const bondsToDelete = new Set(selectedBonds);

                if (atomsToDelete.size === 0 && bondsToDelete.size === 0) return;

                bonds.forEach(b => {
                    if (atomsToDelete.has(b.a1) || atomsToDelete.has(b.a2)) {
                        bondsToDelete.add(b.id);
                    }
                });

                bonds = bonds.filter(b => !bondsToDelete.has(b.id));
                atoms = atoms.filter(a => !atomsToDelete.has(a.id));

                clearSelection();
            }
            svg.addEventListener('mousedown', e => {
                const pos = getMousePos(e);
                dragStartPos = pos;
                const targetElem = e.target;
                const atomId = targetElem.getAttribute('data-atom-id');
                const bondId = targetElem.getAttribute('data-bond-id');

                if (mode === 'lasso') {
                    if (selectedAtoms.size > 0 && isInsideSelectionBox(pos.x, pos.y)) {
                        isDraggingSelection = true;
                        if (selectionRect && selectionRect.parentNode) {
                            selectionRect.parentNode.removeChild(selectionRect);
                        }
                    } else {
                        isSelecting = true;
                        startX = pos.x;
                        startY = pos.y;
                        if (selectionRect && selectionRect.parentNode) {
                            selectionRect.parentNode.removeChild(selectionRect);
                        }
                        selectionRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        selectionRect.setAttribute('id', 'selectionRect');
                        selectionRect.setAttribute('x', startX);
                        selectionRect.setAttribute('y', startY);
                        selectionRect.setAttribute('width', 0);
                        selectionRect.setAttribute('height', 0);
                        svg.appendChild(selectionRect);
                        clearSelection();
                    }
                } else if (mode === 'move') {
                    if (atomId) {
                        const id = parseInt(atomId);
                        if (!selectedAtoms.has(id)) {
                            clearSelection();
                            toggleSelectAtom(id);
                        }
                        isDraggingAtom = true;
                        dragTargetId = id;
                        const atom = atoms.find(a => a.id === dragTargetId);
                        dragStartOffset.x = pos.x - atom.x;
                        dragStartOffset.y = pos.y - atom.y;
                    } else if (bondId) {
                        clearSelection();
                        toggleSelectBond(parseInt(bondId));
                    } else {
                        clearSelection();
                    }
                } else { // mode === 'draw'
                    if (atomId) {
                        isDraggingAtom = true;
                        dragTargetId = parseInt(atomId);
                    } else if (bondId) {
                        const bond = bonds.find(b => b.id === parseInt(bondId));
                        if (bond) {
                            if (currentBond === 'single') {
                                if (bond.type === 'single') bond.type = 'double';
                                else if (bond.type === 'double') bond.type = 'triple';
                                else if (bond.type === 'triple') bond.type = 'single';
                                else bond.type = 'single';
                            } else {
                                bond.type = currentBond;
                            }
                            draw();
                        }
                    } else if (e.target.tagName === 'svg') {
                        addAtom(currentTool, pos.x, pos.y);
                        clearSelection();
                    }
                }
            });

            svg.addEventListener('mousemove', e => {
                const pos = getMousePos(e);

                if (isDraggingSelection) {
                    const dx = pos.x - dragStartPos.x;
                    const dy = pos.y - dragStartPos.y;

                    selectedAtoms.forEach(id => {
                        const atom = atoms.find(a => a.id === id);
                        if (atom) {
                            atom.x += dx;
                            atom.y += dy;
                        }
                    });

                    selectionBox.left += dx;
                    selectionBox.right += dx;
                    selectionBox.top += dy;
                    selectionBox.bottom += dy;

                    dragStartPos = pos;
                    draw();
                    return;
                }

                if (mode === 'lasso' && isSelecting) {
                    const width = Math.abs(pos.x - startX);
                    const height = Math.abs(pos.y - startY);
                    const newX = Math.min(pos.x, startX);
                    const newY = Math.min(pos.y, startY);
                    selectionRect.setAttribute('x', newX);
                    selectionRect.setAttribute('y', newY);
                    selectionRect.setAttribute('width', width);
                    selectionRect.setAttribute('height', height);
                } else if (mode === 'move' && isDraggingAtom) {
                    const atom = atoms.find(a => a.id === dragTargetId);
                    if (atom) {
                        atom.x = pos.x - dragStartOffset.x;
                        atom.y = pos.y - dragStartOffset.y;
                        draw();
                    }
                } else {
                    svg.querySelectorAll('.hover-effect').forEach(el => el.remove());
                    const targetElem = e.target;
                    const atomId = targetElem.getAttribute('data-atom-id');
                    const bondId = targetElem.getAttribute('data-bond-id');
                    const atomMapForHover = new Map(atoms.map(a => [a.id, a]));

                    if (atomId && !selectedAtoms.has(parseInt(atomId))) {
                        const atom = atoms.find(a => a.id === parseInt(atomId));
                        if (atom) {
                            const hoverCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            hoverCircle.setAttribute('cx', atom.x);
                            hoverCircle.setAttribute('cy', atom.y);
                            hoverCircle.setAttribute('r', ATOM_RADIUS + 2);
                            hoverCircle.setAttribute('stroke', HOVER_COLOR);
                            hoverCircle.setAttribute('stroke-width', 2);
                            hoverCircle.setAttribute('fill', 'none');
                            hoverCircle.setAttribute('class', 'hover-effect');
                            svg.appendChild(hoverCircle);
                        }
                    } else if (bondId && !selectedBonds.has(parseInt(bondId))) {
                        const bond = bonds.find(b => b.id === parseInt(bondId));
                        if (bond) {
                            const a1 = atomMapForHover.get(bond.a1);
                            const a2 = atomMapForHover.get(bond.a2);
                            if (!a1 || !a2) return;
                            const hoverLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            hoverLine.setAttribute('x1', a1.x);
                            hoverLine.setAttribute('y1', a1.y);
                            hoverLine.setAttribute('x2', a2.x);
                            hoverLine.setAttribute('y2', a2.y);
                            hoverLine.setAttribute('stroke', HOVER_COLOR);
                            hoverLine.setAttribute('stroke-width', 8);
                            hoverLine.setAttribute('class', 'hover-effect');
                            svg.appendChild(hoverLine);
                        }
                    }
                }
            });

            svg.addEventListener('mouseup', e => {
                const pos = getMousePos(e);
                dragEndPos = pos;
                const dragDistance = Math.sqrt(Math.pow(dragEndPos.x - dragStartPos.x, 2) + Math.pow(dragEndPos.y - dragStartPos.y, 2));

                if (isDraggingSelection) {
                    isDraggingSelection = false;
                    draw();
                    return;
                }

                if (mode === 'lasso') {
                    isSelecting = false;
                    if (selectionRect) {
                        svg.removeChild(selectionRect);
                        selectionRect = null;
                    }

                    if (dragDistance > CLICK_THRESHOLD) {
                        const endX = pos.x;
                        const endY = pos.y;
                        const left = Math.min(startX, endX);
                        const top = Math.min(startY, endY);
                        const width = Math.abs(startX - endX);
                        const height = Math.abs(startY - endY);

                        selectionBox.left = left;
                        selectionBox.top = top;
                        selectionBox.right = left + width;
                        selectionBox.bottom = top + height;

                        atoms.forEach(a => {
                            if (a.x >= left && a.x <= left + width && a.y >= top && a.y <= top + height) {
                                selectedAtoms.add(a.id);
                            }
                        });
                        bonds.forEach(b => {
                            const a1 = atoms.find(a => a.id === b.a1);
                            const a2 = atoms.find(a => a.id === b.a2);
                            if (!a1 || !a2) return;
                            if (selectedAtoms.has(a1.id) && selectedAtoms.has(a2.id)) {
                                selectedBonds.add(b.id);
                            }
                        });
                    } else {
                        if (!isInsideSelectionBox(pos.x, pos.y)) {
                            clearSelection();
                        }
                    }
                    draw();
                } else if (mode === 'move') {
                    isDraggingAtom = false;
                    dragTargetId = null;
                    draw();
                } else if (mode === 'draw' && isDraggingAtom) {
                    if (dragDistance < CLICK_THRESHOLD) {
                        const targetAtom = atoms.find(a => a.id === dragTargetId);
                        if (targetAtom) {
                            targetAtom.elem = currentTool;
                        }
                    } else {
                        const targetAtom = atoms.find(a => a.id !== dragTargetId && Math.sqrt(Math.pow(pos.x - a.x, 2) + Math.pow(pos.y - a.y, 2)) < ATOM_RADIUS);
                        if (targetAtom) {
                            addBond(dragTargetId, targetAtom.id);
                        } else {
                            extendFrom(dragTargetId, pos.x, pos.y);
                        }
                    }
                    isDraggingAtom = false;
                    dragTargetId = null;
                    draw();
                }

                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: e.clientX,
                    clientY: e.clientY
                });
                svg.dispatchEvent(mouseEvent);
            });

            svg.addEventListener('mouseleave', () => {
                isSelecting = false;
                isDraggingAtom = false;
                isDraggingSelection = false;
                dragTargetId = null;
                if (selectionRect) {
                    svg.removeChild(selectionRect);
                    selectionRect = null;
                }
                svg.querySelectorAll('.hover-effect').forEach(el => el.remove());
            });


            document.addEventListener('keydown', e => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    deleteSelectedElements();
                }
            });

            // 导出 PNG：修复实现，排除热点与 hover-effect，保留颜色
            document.getElementById('exportPngBtn').addEventListener('click', () => {
                const svgElement = document.getElementById('draw-svg');
                clearSelection();
                svgElement.querySelectorAll('.hover-effect').forEach(el => el.remove());
                let bbox;
                try {
                    bbox = svgElement.getBBox();
                    if (bbox.width === 0 || bbox.height === 0) {
                        alert('画布为空，无法导出！');
                        return;
                    }
                } catch (e) {
                    alert('画布为空或浏览器不支持，无法导出！');
                    return;
                }
                const margin = 15;
                const width = Math.ceil(bbox.width + 2 * margin);
                const height = Math.ceil(bbox.height + 2 * margin);
                const translateX = -bbox.x + margin;
                const translateY = -bbox.y + margin;
                const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                tempSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                tempSvg.setAttribute('width', width);
                tempSvg.setAttribute('height', height);
                tempSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('transform', `translate(${translateX}, ${translateY})`);
                Array.from(svgElement.children).forEach(child => {
                    if (child.id === 'selectionRect') return;
                    const cls = child.getAttribute('class') || '';
                    if (cls.includes('selectable-atom') || cls.includes('selectable-bond') || cls.includes('hover-effect')) {
                        return;
                    }
                    const clonedChild = child.cloneNode(true);
                    if (clonedChild.tagName === 'text') {
                        const atomId = clonedChild.getAttribute('data-atom-id');
                        const atom = atoms.find(a => a.id === parseInt(atomId));
                        if (atom) clonedChild.setAttribute('fill', getCssColor(atom.elem));
                    }
                    if (clonedChild.tagName === 'line') {
                        const stroke = clonedChild.getAttribute('stroke');
                        if (!stroke) clonedChild.setAttribute('stroke', getCssColor('bond'));
                    }
                    if (clonedChild.tagName === 'g' || clonedChild.tagName === 'polygon' || clonedChild.tagName === 'path') {
                        if (clonedChild.tagName === 'g') {
                            Array.from(clonedChild.querySelectorAll('*')).forEach(ch => {
                                if ((ch.tagName === 'polygon' || ch.tagName === 'path') && !ch.getAttribute('fill')) ch.setAttribute('fill', getCssColor('bond'));
                                if (ch.tagName === 'line' && !ch.getAttribute('stroke')) ch.setAttribute('stroke', getCssColor('bond'));
                            });
                        } else {
                            if ((clonedChild.tagName === 'polygon' || clonedChild.tagName === 'path') && !clonedChild.getAttribute('fill')) clonedChild.setAttribute('fill', getCssColor('bond'));
                        }
                    }
                    g.appendChild(clonedChild);
                });
                tempSvg.appendChild(g);
                const svgData = new XMLSerializer().serializeToString(tempSvg);
                const img = new Image();
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                img.onload = function () {
                    const canvas = document.createElement('canvas');
                    canvas.width = width; canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0);
                    const dataURL = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = dataURL;
                    a.download = 'molecular_structure_transparent.png';
                    document.body.appendChild(a); a.click(); document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };
                img.src = url;
            });

            function downloadJSON(data) {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'molecular_structure.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- 工具栏按钮逻辑 ---
            document.querySelectorAll('#toolbar button').forEach(btn => {
                btn.addEventListener('click', () => {

                    if (btn.id === 'deleteBtn' || btn.id === 'exportPngBtn') {
                        if (btn.id === 'deleteBtn') deleteSelectedElements();
                        // 导出按钮逻辑已在上方实现
                        return;
                    }

                    clearSelection();

                    if (btn.classList.contains('mode-btn')) {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        mode = btn.id === 'drawBtn' ? 'draw' : btn.id === 'moveBtn' ? 'move' : 'lasso';
                    } else if (btn.classList.contains('atom-btn')) {
                        document.querySelectorAll('.atom-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentTool = btn.dataset.tool;
                        document.getElementById('drawBtn').click();
                    } else if (btn.classList.contains('bond-btn')) {
                        document.querySelectorAll('.bond-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentBond = btn.dataset.bond;
                        document.getElementById('drawBtn').click();
                    }
                    updateCanvasCursor();
                });
            });

            // 背景颜色选择器
            const drawBgPicker = document.getElementById('draw-bg-picker');
            const drawBgPickerContainer = document.getElementById('draw-bg-picker-container');
            const drawColorSwatches = document.querySelectorAll('.draw-color-swatch');

            drawBgPicker.addEventListener('input', (e) => {
                updateDrawTheme(e.target.value);
                drawBgPickerContainer.style.backgroundColor = e.target.value;
            });

            drawColorSwatches.forEach(swatch => {
                swatch.addEventListener('click', (e) => {
                    const color = e.target.getAttribute('data-color');
                    drawBgPicker.value = color;
                    updateDrawTheme(color);
                    drawBgPickerContainer.style.backgroundColor = color;
                });
            });

            // 初始设置默认工具
            document.getElementById('drawBtn').click();
            document.querySelector('.atom-btn[data-tool="C"]').classList.add('active');
            document.querySelector('.bond-btn[data-bond="single"]').classList.add('active');

            draw();
        })();
    </script>

    <!-- 3D部分脚本 -->
    <script>
        // 3D应用对象
        window.d3App = (function () {
 
            const ATOM_RADII = { 'C': 0.77, 'H': 0.37, 'O': 0.73, 'N': 0.75, 'S': 1.02 };
            const ATOM_COLORS = { 'C': 0xBBBBBB, 'H': 0x888888, 'O': 0x6495ED, 'N': 0xB2B01D, 'S': 0xCC99A2 };
            const BALL_STICK_SCALE_FACTOR = 0.4, BOND_RADIUS_BALL_STICK = 0.08, STICK_RADIUS = 0.12;
            const HIGHLIGHT_COLOR = 0xFFFF00, INITIAL_CAMERA_DISTANCE = 15, AXIS_CAMERA_DISTANCE = 3.5;

            let scene, camera, renderer, controls, moleculeGroup, ambientLight, directionalLight;
            let atomMeshes = [], bondMeshes = [], highlightedAtom = null, sxyzData = null, adjData = null;
            let currentRenderType = 'ball_stick', currentBackgroundColor = 0xFFFFFF;
            let axisScene, axisCamera, axisRenderer, axisGroup, axisRendererContainer;
            const AXIS_SIZE = 80;
            // let currentRenderType = 'ball_stick';

            const d3Container = document.getElementById('d3-container');

            function getLuminance(hexColor) {
                if (typeof hexColor === 'number') hexColor = '#' + hexColor.toString(16).padStart(6, '0');
                const r = parseInt(hexColor.slice(1, 3), 16) / 255, g = parseInt(hexColor.slice(3, 5), 16) / 255, b = parseInt(hexColor.slice(5, 7), 16) / 255;
                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            }

            function getButtonTextColor(bgColorHex) { return getLuminance(bgColorHex) > 0.6 ? '#333333' : '#FFFFFF'; }

            function updateControlTextAndThemeColor(hexColor) {
                const root = d3Container.style;
                const isLightBackground = getLuminance(hexColor) > 0.3;
                const theme = isLightBackground ? 'dark' : 'light';
                root.setProperty('--current-text-color', `var(--color-text-${theme === 'dark' ? 'light' : 'dark'})`);
                ['load', 'light', 'params', 'export'].forEach(type => {
                    root.setProperty(`--current-${type}-color`, `var(--color-${type}-${theme})`);
                });
                root.setProperty('--current-toggle-active', `var(--color-params-${theme})`);
                setupUIStyles();
                const textColor = getComputedStyle(d3Container).getPropertyValue('--current-text-color');
                d3Container.querySelector('#background-color-picker-container').style.borderColor = textColor;
                d3Container.querySelectorAll('.color-swatch').forEach(swatch => swatch.style.borderColor = textColor);
            }

            function updateInfoTextColor(hexColor) {
                const textColor = getLuminance(hexColor) > 0.5 ? '#000000' : '#FFFFFF';
                d3Container.querySelector('#highlight-info').style.color = textColor;
                d3Container.querySelector('#controls-label').style.color = textColor;
                d3Container.querySelector('#toggle-button-wrapper').style.color = textColor;
            }

            function colorToHex(color) {
                if (typeof color === 'number') return '#' + color.toString(16).padStart(6, '0').toUpperCase();
                if (color instanceof THREE.Color) return '#' + color.getHexString().toUpperCase();
                return '#--';
            }

            function updateHighlightInfo(atom) {
                const symbolEl = d3Container.querySelector('#highlight-symbol'), indexEl = d3Container.querySelector('#highlight-index');
                const colorEl = d3Container.querySelector('#highlight-color'), coordsEl = d3Container.querySelector('#highlight-coords');
                if (atom && atom.userData) {
                    const data = atom.userData;
                    symbolEl.textContent = data.symbol;
                    indexEl.textContent = data.index;
                    const colorHex = colorToHex(data.baseColor);
                    colorEl.textContent = colorHex;
                    colorEl.style.color = colorHex;
                    coordsEl.textContent = `(${(data.X || 0).toFixed(2)}, ${(data.Y || 0).toFixed(2)}, ${(data.Z || 0).toFixed(2)})`;
                } else {
                    symbolEl.textContent = '无'; indexEl.textContent = '--';
                    colorEl.textContent = '#--'; colorEl.style.color = 'inherit';
                    coordsEl.textContent = '----';
                }
            }

            function exportView(format) {
                if (format !== 'png' || !renderer) return;
                const originalBackground = scene.background, originalAlpha = renderer.getClearAlpha();
                scene.background = null; if (renderer.setClearAlpha) renderer.setClearAlpha(0);
                renderer.render(scene, camera);
                const imgData = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'molecule_3d_view.png';
                link.href = imgData;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
                if (renderer.setClearAlpha) renderer.setClearAlpha(originalAlpha); scene.background = originalBackground; renderer.render(scene, camera);
            }

            function clearHighlight() {
                if (highlightedAtom) {
                    highlightedAtom.material.emissive.set(0x000000);
                    highlightedAtom = null;
                }
                bondMeshes.forEach(mesh => { if (mesh.userData.isBond) mesh.material.emissive.set(0x000000); });
                updateHighlightInfo(null);
            }

            function highlightAtomAndBonds(atom) {
                clearHighlight();
                if (!atom) return;
                atom.material.emissive.set(HIGHLIGHT_COLOR);
                highlightedAtom = atom;
                updateHighlightInfo(atom);
                if (currentRenderType !== 'stick') return;
                const atomIndex = highlightedAtom.userData.index;
                bondMeshes.forEach(mesh => {
                    if (mesh.userData.isBond) {
                        const { atomAIndex, atomBIndex, atomSide } = mesh.userData;
                        if ((atomAIndex === atomIndex && atomSide === 'A') || (atomBIndex === atomIndex && atomSide === 'B')) {
                            mesh.material.emissive.set(HIGHLIGHT_COLOR);
                        }
                    }
                });
            }

            function initAxisHelper() {
                axisRendererContainer = d3Container.querySelector('#axis-renderer-container');
                axisScene = new THREE.Scene();
                axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                axisCamera.position.set(AXIS_CAMERA_DISTANCE, AXIS_CAMERA_DISTANCE, AXIS_CAMERA_DISTANCE);
                axisCamera.up.set(0, 1, 0); axisCamera.lookAt(0, 0, 0);
                axisRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                axisRenderer.setSize(AXIS_SIZE, AXIS_SIZE);
                axisRenderer.setClearColor(0x000000, 0);
                axisRendererContainer.appendChild(axisRenderer.domElement);
                axisGroup = new THREE.Group();
                axisScene.add(axisGroup);
                const axesData = [
                    { dir: new THREE.Vector3(1.5, 0, 0), color: 0xD62828, text: 'X' },
                    { dir: new THREE.Vector3(0, 1.5, 0), color: 0x008000, text: 'Y' },
                    { dir: new THREE.Vector3(0, 0, 1.5), color: 0x0000FF, text: 'Z' },
                ];
                const cylGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 16);
                axesData.forEach(data => {
                    const material = new THREE.MeshBasicMaterial({ color: data.color });
                    const cylinder = new THREE.Mesh(cylGeom, material);
                    cylinder.position.copy(data.dir).multiplyScalar(0.5);
                    cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), data.dir.clone().normalize());
                    axisGroup.add(cylinder);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture(data.text, data.color), sizeAttenuation: false, depthTest: false }));
                    sprite.position.copy(data.dir).add(new THREE.Vector3(0.3, 0.3, 0.3));
                    sprite.scale.set(0.3, 0.3, 0.3);
                    axisGroup.add(sprite);
                });
                axisScene.add(new THREE.AmbientLight(0xFFFFFF, 1.0));
            }

            function createTextTexture(text, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64; canvas.height = 64;
                context.font = 'Bold 30px Arial';
                context.fillStyle = '#' + new THREE.Color(color).getHexString();
                context.textAlign = 'center'; context.textBaseline = 'middle';
                context.fillText(text, 32, 37);
                return new THREE.CanvasTexture(canvas);
            }

            function updateAxisHelper() {
                if (!axisGroup || !controls) return;
                axisGroup.quaternion.copy(camera.quaternion).invert();
                axisRenderer.render(axisScene, axisCamera);
            }

            function onWindowResize() {
                const rect = d3Container.getBoundingClientRect();
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                renderer.setSize(rect.width, rect.height);
                if (axisCamera) {
                    axisCamera.aspect = 1;
                    axisCamera.updateProjectionMatrix();
                }
            }

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(currentBackgroundColor);
                camera = new THREE.PerspectiveCamera(75, d3Container.clientWidth / d3Container.clientHeight, 0.1, 1000);
                camera.position.set(-INITIAL_CAMERA_DISTANCE, -INITIAL_CAMERA_DISTANCE, -INITIAL_CAMERA_DISTANCE);
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(d3Container.clientWidth, d3Container.clientHeight);
                d3Container.appendChild(renderer.domElement);
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.top = '0';
                renderer.domElement.style.left = '0';
                renderer.domElement.style.zIndex = '0';

                initAxisHelper();
                updateInfoTextColor(currentBackgroundColor);
                updateControlTextAndThemeColor(currentBackgroundColor);

                ambientLight = new THREE.AmbientLight(0x404040, 4.0);
                scene.add(ambientLight);
                directionalLight = new THREE.DirectionalLight(0xffffff, 0.0);
                directionalLight.position.set(10, 10, 10).normalize();
                scene.add(directionalLight);
                setLightPreset('3d');

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.PAN,
                    MIDDLE: THREE.MOUSE.ROTATE,
                    RIGHT: THREE.MOUSE.DOLLY
                };
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.addEventListener('change', updateAxisHelper);

                const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
                let isDragging = false;
                renderer.domElement.addEventListener('pointerdown', () => { isDragging = false; });
                renderer.domElement.addEventListener('pointermove', () => { isDragging = true; });
                renderer.domElement.addEventListener('pointerup', (event) => {
                    if (isDragging) return;
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(atomMeshes);
                    const newHighlightedAtom = intersects.length > 0 ? intersects[0].object : null;
                    if (highlightedAtom === newHighlightedAtom) clearHighlight();
                    else highlightAtomAndBonds(newHighlightedAtom);
                }, false);

                window.addEventListener('resize', onWindowResize, false);
                setupLightControls();
                setupParamsControls();
                setupToggleControl();
                onWindowResize();
                controls.target.set(0, 0, 0);
                controls.update();
                updateAxisHelper();
                animate();
            }

            function animate() {
                requestAnimationFrame(animate);
                if (controls.enabled) controls.update();
                renderer.render(scene, camera);
                updateAxisHelper();
            }

            function setupUIStyles() {
                const root = getComputedStyle(d3Container);
                const colors = {
                    load: root.getPropertyValue('--current-load-color').trim(),
                    light: root.getPropertyValue('--current-light-color').trim(),
                    export: root.getPropertyValue('--current-export-color').trim(),
                    params: root.getPropertyValue('--current-params-color').trim(),
                };
                d3Container.querySelector('#file-input-panel h3').style.color = colors.load;
                d3Container.querySelectorAll('#file-input-panel .load-button').forEach(btn => { btn.style.backgroundColor = colors.load; btn.style.color = getButtonTextColor(colors.load); });
                d3Container.querySelector('#status-message').style.color = colors.load;
                d3Container.querySelector('#light-controls-panel h3').style.color = colors.light;
                d3Container.querySelectorAll('#light-controls-panel .light-button').forEach(btn => { btn.style.backgroundColor = colors.light; btn.style.color = getButtonTextColor(colors.light); });
                d3Container.querySelector('#params-controls-panel h3').style.color = colors.params;
                d3Container.querySelector('#export-controls-panel h3').style.color = colors.export;
                const exportBtn = d3Container.querySelector('#export-controls-panel .export-button');
                if (exportBtn) { exportBtn.style.backgroundColor = colors.export; exportBtn.style.color = getButtonTextColor(colors.export); }
            }

            function setLightPreset(preset) {
                const p = preset === 'clear' ? { a: 4.0, d: 0.1 } : { a: 2.5, d: 0.8 };
                ambientLight.intensity = p.a;
                directionalLight.intensity = p.d;
                d3Container.querySelector('#ambient-light-range').value = p.a;
                d3Container.querySelector('#directional-light-range').value = p.d;
                d3Container.querySelector('#ambient-value').textContent = p.a.toFixed(1);
                d3Container.querySelector('#directional-value').textContent = p.d.toFixed(1);
            }

            function setupLightControls() {
                const ambientRange = d3Container.querySelector('#ambient-light-range'), dirRange = d3Container.querySelector('#directional-light-range');
                const ambientVal = d3Container.querySelector('#ambient-value'), dirVal = d3Container.querySelector('#directional-value');
                ambientRange.addEventListener('input', (e) => { ambientLight.intensity = parseFloat(e.target.value); ambientVal.textContent = ambientLight.intensity.toFixed(1); });
                dirRange.addEventListener('input', (e) => { directionalLight.intensity = parseFloat(e.target.value); dirVal.textContent = directionalLight.intensity.toFixed(1); });
            }

            function setupParamsControls() {
                const picker = d3Container.querySelector('#background-color-picker'), container = d3Container.querySelector('#background-color-picker-container');
                const hydrogenToggle = d3Container.querySelector('#show-hydrogen'), swatches = d3Container.querySelectorAll('.color-swatch');
                const updateBg = (hex) => {
                    if (!scene) return;
                    scene.background.set(hex);
                    currentBackgroundColor = scene.background.getHex();
                    container.style.backgroundColor = hex;
                    updateInfoTextColor(currentBackgroundColor);
                    updateControlTextAndThemeColor(currentBackgroundColor);
                };
                picker.addEventListener('input', (e) => updateBg(e.target.value));
                swatches.forEach(s => s.addEventListener('click', (e) => { const c = e.target.dataset.color; picker.value = c; updateBg(c); }));
                hydrogenToggle.addEventListener('change', () => { if (sxyzData && adjData) drawMolecule(currentRenderType, sxyzData, adjData); });
                updateBg(picker.value);
            }

            function setupToggleControl() {
                const toggle = d3Container.querySelector('#controls-toggle'), wrapper = d3Container.querySelector('#controls-container-wrapper');
                const updateTransform = () => wrapper.style.transform = toggle.checked ? 'translateX(0)' : `translateX(${wrapper.offsetWidth + 20}px)`;
                updateTransform();
                toggle.addEventListener('change', updateTransform);
                new ResizeObserver(updateTransform).observe(wrapper);
            }

            function drawMolecule(renderType, sxyzData, adjData) {
                if (moleculeGroup) scene.remove(moleculeGroup);
                atomMeshes = []; bondMeshes = []; clearHighlight();
                moleculeGroup = new THREE.Group();
                scene.add(moleculeGroup);
                const showH = d3Container.querySelector('#show-hydrogen').checked;
                const drawFunc = renderType === 'stick' ? drawAtomsAndBonds_Stick : drawAtomsAndBonds_BallStick;
                drawFunc(sxyzData, adjData, showH);
                centerAndZoom(sxyzData);
            }

            function drawAtomsAndBonds_BallStick(sxyzData, adjData, showH) {
                const atomGeom = new THREE.SphereGeometry(1, 32, 32);
                sxyzData.forEach((atom, index) => {
                    const symbol = String(atom.Symbol).trim().toUpperCase();
                    if (!showH && symbol === 'H') return;
                    const radius = (ATOM_RADII[symbol] || 0.5) * BALL_STICK_SCALE_FACTOR;
                    const color = ATOM_COLORS[symbol] || 0xCCCCCC;
                    const material = new THREE.MeshStandardMaterial({ color, emissive: 0x0, metalness: 0.1, roughness: 0.5 });
                    const mesh = new THREE.Mesh(atomGeom, material);
                    mesh.scale.set(radius, radius, radius);
                    mesh.position.set(atom.X, atom.Y, atom.Z);
                    mesh.userData = { ...atom, symbol, index: index + 1, baseColor: color, isAtom: true };
                    atomMeshes.push(mesh);
                    moleculeGroup.add(mesh);
                });
                const bondGeom = new THREE.CylinderGeometry(BOND_RADIUS_BALL_STICK, BOND_RADIUS_BALL_STICK, 1, 16);
                const bondMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.1, roughness: 0.8 });
                adjData.forEach(bond => {
                    const iA = (bond.A || 0) - 1, iB = (bond.B || 0) - 1;
                    if (iA < 0 || iB < 0 || iA >= sxyzData.length || iB >= sxyzData.length) return;
                    const sA = String(sxyzData[iA].Symbol).trim().toUpperCase(), sB = String(sxyzData[iB].Symbol).trim().toUpperCase();
                    if (!showH && (sA === 'H' || sB === 'H')) return;
                    const posA = new THREE.Vector3(sxyzData[iA].X, sxyzData[iA].Y, sxyzData[iA].Z);
                    const posB = new THREE.Vector3(sxyzData[iB].X, sxyzData[iB].Y, sxyzData[iB].Z);
                    const center = new THREE.Vector3().addVectors(posA, posB).divideScalar(2);
                    const bondMesh = new THREE.Mesh(bondGeom, bondMat.clone());
                    bondMesh.scale.set(1, posA.distanceTo(posB), 1);
                    bondMesh.position.copy(center);
                    bondMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(posB, posA).normalize());
                    bondMesh.userData = { isBond: true, atomAIndex: iA + 1, atomBIndex: iB + 1 };
                    bondMeshes.push(bondMesh);
                    moleculeGroup.add(bondMesh);
                });
            }

            function drawAtomsAndBonds_Stick(sxyzData, adjData, showH) {
                const atomGeom = new THREE.SphereGeometry(1, 32, 32);
                sxyzData.forEach((atom, index) => {
                    const symbol = String(atom.Symbol).trim().toUpperCase();
                    if (!showH && symbol === 'H') return;
                    const color = ATOM_COLORS[symbol] || 0xCCCCCC;
                    const material = new THREE.MeshStandardMaterial({ color, emissive: 0x0, metalness: 0.1, roughness: 0.5 });
                    const mesh = new THREE.Mesh(atomGeom, material);
                    mesh.scale.set(STICK_RADIUS, STICK_RADIUS, STICK_RADIUS);
                    mesh.position.set(atom.X, atom.Y, atom.Z);
                    mesh.userData = { ...atom, symbol, index: index + 1, baseColor: color, isAtom: true };
                    atomMeshes.push(mesh);
                    moleculeGroup.add(mesh);
                });
                const bondGeom = new THREE.CylinderGeometry(STICK_RADIUS, STICK_RADIUS, 1, 16);
                adjData.forEach(bond => {
                    const iA = (bond.A || 0) - 1, iB = (bond.B || 0) - 1;
                    if (iA < 0 || iB < 0 || iA >= sxyzData.length || iB >= sxyzData.length) return;
                    const sA = String(sxyzData[iA].Symbol).trim().toUpperCase(), sB = String(sxyzData[iB].Symbol).trim().toUpperCase();
                    if (!showH && (sA === 'H' || sB === 'H')) return;
                    const cA = ATOM_COLORS[sA] || 0xCCCCCC, cB = ATOM_COLORS[sB] || 0xCCCCCC;
                    const posA = new THREE.Vector3(sxyzData[iA].X, sxyzData[iA].Y, sxyzData[iA].Z);
                    const posB = new THREE.Vector3(sxyzData[iB].X, sxyzData[iB].Y, sxyzData[iB].Z);
                    const halfDist = posA.distanceTo(posB) / 2;
                    const dir = new THREE.Vector3().subVectors(posB, posA).normalize();
                    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                    ['A', 'B'].forEach(side => {
                        const mat = new THREE.MeshStandardMaterial({ color: side === 'A' ? cA : cB, emissive: 0x0, metalness: 0.1, roughness: 0.8 });
                        const mesh = new THREE.Mesh(bondGeom, mat);
                        mesh.scale.set(1, halfDist, 1);
                        mesh.position.copy(side === 'A' ? posA : posB).addScaledVector(dir, side === 'A' ? halfDist / 2 : -halfDist / 2);
                        mesh.quaternion.copy(quat);
                        mesh.userData = { isBond: true, atomAIndex: iA + 1, atomBIndex: iB + 1, atomSide: side };
                        bondMeshes.push(mesh);
                        moleculeGroup.add(mesh);
                    });
                });
            }

            function centerAndZoom(sxyzData) {
                if (!moleculeGroup || sxyzData.length === 0) return;
                const box = new THREE.Box3().setFromObject(moleculeGroup);
                const center = new THREE.Vector3();
                box.getCenter(center);
                moleculeGroup.position.sub(center);
                const size = new THREE.Vector3();
                box.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                let camDist = Math.abs(maxDim / 2 / Math.tan(camera.fov * (Math.PI / 180) / 2)) * 1.5;
                controls.target.set(0, 0, 0);
                const d = camDist / Math.sqrt(3);
                camera.position.set(-d, -d, -d).multiplyScalar(1.7);
                camera.lookAt(controls.target);
                controls.update();
            }


            // 添加从JSON直接加载数据的函数
            function loadJsonData(jsonData, renderType = 'ball_stick') {
                console.log('加载JSON数据:', jsonData, '渲染类型:', renderType);

                try {
                    // 将SXYZ格式转换为CSV格式
                    // jsonData.SXYZ格式: [["C", 0.0, 0.0, 0.0], ...]
                    // 需要转换为: [{Symbol: "C", X: 0.0, Y: 0.0, Z: 0.0}, ...]
                    const convertedSXYZ = jsonData.SXYZ.map((item, index) => ({
                        Symbol: item[0],
                        X: parseFloat(item[1]),
                        Y: parseFloat(item[2]),
                        Z: parseFloat(item[3])
                    }));

                    // 将ADJ_AB格式转换为CSV格式
                    // jsonData.ADJ_AB格式: [[1, 2], [1, 3], ...]
                    // 需要转换为: [{A: 1, B: 2}, ...]
                    const convertedADJ = jsonData.ADJ_AB.map(item => ({
                        A: parseInt(item[0]),
                        B: parseInt(item[1])
                    }));

                    console.log('转换后的SXYZ数据:', convertedSXYZ);
                    console.log('转换后的ADJ数据:', convertedADJ);

                    // 保存数据
                    sxyzData = convertedSXYZ;
                    adjData = convertedADJ;

                    // 使用传入的渲染类型
                    currentRenderType = renderType;
                    const status = document.getElementById('status-message');
                    if (status) {
                        status.textContent = '正在渲染3D结构...';
                    }

                    // 调用渲染函数
                    drawMolecule(renderType, sxyzData, adjData);
                    if (status) {
                        const modelName = renderType === 'stick' ? '棒状模型' : '球棍模型';
                        status.textContent = `3D结构已渲染 (${modelName})`;
                    }

                } catch (error) {
                    console.error('加载JSON数据失败:', error);
                    const status = document.getElementById('status-message');
                    if (status) {
                        status.textContent = '错误: ' + error.message;
                    }
                }
            }

            // 从文件加载和绘制
            async function loadAndDraw(renderType) {
                const status = document.getElementById('status-message');
                status.textContent = "正在加载...";

                try {
                    // 如果已经有数据，直接重新渲染
                    if (sxyzData && adjData) {
                        console.log('使用已加载的数据重新渲染:', renderType);
                        currentRenderType = renderType;
                        drawMolecule(renderType, sxyzData, adjData);
                        const modelName = renderType === 'stick' ? '棒状模型' : '球棍模型';
                        status.textContent = `3D结构已渲染 (${modelName})`;
                        return;
                    }

                    // 检查是否有文件选择
                    const fileInput = document.getElementById('json3d-file');
                    if (!fileInput.files.length) {
                        throw new Error('请先选择3d.json文件或使用左侧转换功能');
                    }

                    // 读取JSON文件
                    const file = fileInput.files[0];
                    const text = await file.text();
                    const jsonData = JSON.parse(text);

                    console.log('从文件加载的JSON数据:', jsonData);

                    // 使用相同的加载函数，传入渲染类型
                    loadJsonData(jsonData, renderType);

                } catch (error) {
                    status.textContent = `错误: ${error.message}`;
                    console.error(error);
                }
            }

            init();
            d3Container.querySelector('#status-message').textContent = "等待从左侧画布转换数据...";

            // 暴露公共接口
            return {
                loadJsonData: loadJsonData,
                loadAndDraw: loadAndDraw,
                setLightPreset: setLightPreset,
                exportView: exportView,
                onWindowResize: onWindowResize,
                controls: controls
            };
        })();
    </script>
</body>
</html>