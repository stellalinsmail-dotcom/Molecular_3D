<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>有机分子结构绘制工具 | 简约版 V3</title>
    <style>
        /* --- CSS Start --- */

        :root {
            /* 颜色变量 */
            --bg-dark: #20232A; /* 整体深色背景 */
            --toolbar-bg: #282C34; /* 工具栏背景 */
            --canvas-bg: #FFFFFF; /* 画布背景 */
            --border-color: #3C424F; /* 分隔线/边框颜色 */
            --text-color-light: #F8F8F8; /* 浅色文字 */
            --active-bg: #3C424F; /* 激活背景色 */
            --hover-bg: #4A515F; /* 悬停背景色 */
            /* 按钮主题色 */
            --atom-color: #61AFEF; /* 原子按钮主色 */
            --bond-color: #98C379; /* 键按钮主色 */
            --mode-color: #C678DD; /* 模式按钮主色 */
            --delete-color: #E06C75; /* 删除按钮色 */
            --export-color: #FFD700; /* 导出按钮色 */ /* 新增颜色变量 */
            /* 原子颜色 (恢复第一版设置) */
            --color-C: #282C34;
            --color-H: #A9A9A9;
            --color-O: #87CEFA;
            --color-N: #FFD700;
            --color-S: #FFB6C1;
        }

        body {
            margin: 0;
            background: var(--bg-dark);
            color: var(--text-color-light);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* 1. 工具栏宽度设置为 100px */
        #toolbar {
            width: 120px;
            background: var(--toolbar-bg);
            padding: 10px 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
        }

        /* 2. 缩窄组内按钮间距和组底部间距 */
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 5px;
        }

        .divider {
            height: 1px;
            background: var(--border-color);
            margin: 5px 0;
        }

        .section-title {
            font-size: 10px;
            color: #9DA5B4;
            text-transform: uppercase;
            margin-bottom: 5px;
            text-align: center;
        }

        /* 2. 缩窄按钮高度并居中文字 */
        button {
            width: 100%;
            padding: 5px 3px;
            font-size: 12px;
            line-height: 1.2;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color-light);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease-in-out;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: center;
        }

            button:hover {
                background: var(--hover-bg);
                border-color: var(--hover-bg);
                color: var(--text-color-light);
            }

            button.active {
                background: var(--active-bg);
                border-color: var(--active-bg);
                box-shadow: 0 0 5px rgba(97, 175, 239, 0.5);
            }

        .atom-btn.active {
            color: var(--atom-color);
            border-color: var(--atom-color);
        }

        .bond-btn.active {
            color: var(--bond-color);
            border-color: var(--bond-color);
        }

        .mode-btn.active {
            color: var(--mode-color);
            border-color: var(--mode-color);
        }

        /* 2. 导出按钮样式 (同删除键格式) */
        #exportPngBtn {
            background: var(--export-color);
            border-color: var(--export-color);
            color: var(--color-C); /* 导出键文字使用深色，与背景对比 */
            font-weight: bold;
            margin-top: 10px;
        }

            #exportPngBtn:hover {
                background: #D4AF37;
                border-color: #D4AF37;
            }

        /* CSV 导出按钮样式，放在 PNG 上方，使用同样主题但稍浅 */
        #exportCsvBtn {
            background: #FFE599;
            border-color: #FFE599;
            color: var(--color-C);
            font-weight: bold;
            margin-top: 5px;
        }

            #exportCsvBtn:hover {
                background: #FFEB9C;
                border-color: #FFEB9C;
            }

        #deleteBtn {
            background: var(--delete-color);
            border-color: var(--delete-color);
            font-weight: bold;
            margin-top: 5px; /* 调整间距，留给导出按钮 */
        }

            #deleteBtn:hover {
                background: #B94451;
                border-color: #B94451;
            }

        /* 1. 楔形键按钮样式（使用SVG作为图标） */
        .wedge-icon {
            width: 16px;
            height: 10px;
            overflow: visible;
        }

        /* 画布区域 */
        #canvas {
            flex: 1;
            background: var(--canvas-bg);
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

            /* ... 省略其他不变的 SVG/Canvas 样式 ... */

            svg .selectable-atom {
                stroke: transparent;
                fill: transparent;
                stroke-width: 2;
                cursor: pointer;
            }

                svg .selectable-atom.selected {
                    stroke: #FFD700;
                    stroke-width: 3;
                    fill: rgba(255, 255, 0, 0.1);
                }

            svg .selectable-bond {
                stroke: transparent;
                stroke-width: 10;
                cursor: pointer;
            }

                svg .selectable-bond.selected {
                    stroke: #FFD700;
                }

            svg text {
                user-select: none;
                pointer-events: none;
            }

        #selectionRect {
            fill: rgba(100, 150, 255, 0.1);
            stroke: #61AFEF;
            stroke-width: 1;
            stroke-dasharray: 4, 2;
        }

        #titles {
            display: none;
        }

        /* --- CSS End --- */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvg/3.0.10/canvg.min.js"></script>
</head>
<body>
    <div id="toolbar">
        <div class="button-group">
            <div class="section-title">原子 (Atom)</div>
            <button data-tool="C" class="atom-btn active">C</button>
            <button data-tool="H" class="atom-btn">H</button>
            <button data-tool="O" class="atom-btn">O</button>
            <button data-tool="N" class="atom-btn">N</button>
            <button data-tool="S" class="atom-btn">S</button>
        </div>
        <div class="divider"></div>
        <div class="button-group">
            <div class="section-title">键 (Bond)</div>
            <button data-bond="single" class="bond-btn active">单键</button>
            <button data-bond="double" class="bond-btn">双键</button>
            <button data-bond="triple" class="bond-btn">三键</button>

            <button data-bond="wedge-up" class="bond-btn" id="wedgeUpBtn">
                <svg class="wedge-icon" viewBox="0 0 16 10">
                    <polygon points="0,5 16,10 16,0" fill="currentColor" />
                </svg>
            </button>
            <button data-bond="wedge-down" class="bond-btn" id="wedgeDownBtn">
                <svg class="wedge-icon" viewBox="0 0 16 10">
                    <g fill="currentColor">
                        <polygon points="0,5 5,6.5 5,3.5" />
                        <polygon points="6,3 11,8 11,2" />
                        <polygon points="12,1 16,9 16,1" />
                    </g>
                </svg>
            </button>
        </div>
        <div class="divider"></div>
        <div class="button-group">
            <div class="section-title">功能 (Tool)</div>
            <button id="drawBtn" class="mode-btn active">✏️ 构造</button>
            <button id="moveBtn" class="mode-btn">🤚 移动</button>
            <button id="lassoBtn" class="mode-btn">🔲 套索</button>

            <button id="exportCsvBtn">📄 导出 CSV</button>
            <button id="exportPngBtn">📷 导出 PNG</button>

            <button id="deleteBtn">🗑️ 删除</button>
        </div>
    </div>
    <div id="canvas">
        <svg id="svg"></svg>
    </div>

    <script>
        // --- JavaScript Start ---
        // 1. 恢复第一版原子颜色设置，并映射到 CSS 变量
        const colors = {
            C: 'var(--color-C)',
            H: 'var(--color-H)',
            O: 'var(--color-O)',
            N: 'var(--color-N)',
            S: 'var(--color-S)'
        };

        // 获取 CSS 变量的值用于 JS 逻辑
        const getCssColor = (elem) => {
            const style = getComputedStyle(document.documentElement);
            return style.getPropertyValue(`--color-${elem}`).trim();
        };

        let atoms = [];
        let bonds = [];
        let selectedAtoms = new Set();
        let selectedBonds = new Set();
        let currentTool = 'C';
        let currentBond = 'single';
        let nextAtomId = 0;
        let nextBondId = 0;
        let mode = 'draw';
        let dragStartPos = { x: 0, y: 0 };
        let dragEndPos = { x: 0, y: 0 };
        let isDraggingAtom = false;
        let dragTargetId = null;
        let dragStartOffset = { x: 0, y: 0 };
        let isDraggingSelection = false;

        const svg = document.getElementById('svg');
        const canvas = document.getElementById('canvas');

        let isSelecting = false;
        let startX = 0;
        let startY = 0;
        let selectionRect;
        let selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };


        const ATOM_RADIUS = 10;
        const ATOM_FONT_SIZE = '14px';


        const BOND_STROKE_WIDTH = 2 //键的宽度
        const BOND_END_OFFSET = 10; // 键缩短的长度
        const BOND_TYPE_OFFSET = 3;
        const WEDGE_WIDTH = 8; // 楔形键的宽度

        const HIGHLIGHT_COLOR = 'rgba(255, 255, 200, 0.5)';
        const HOVER_COLOR = 'rgba(97, 175, 239, 0.5)';
        const CLICK_THRESHOLD = 5;


        function draw() {
            svg.innerHTML = '';
            const atomMap = new Map(atoms.map(a => [a.id, a]));
            const bondCount = atoms.reduce((acc, atom) => {
                acc[atom.id] = bonds.filter(b => b.a1 === atom.id || b.a2 === atom.id).length;
                return acc;
            }, {});

            const bondColor = getCssColor('C'); // 使用 C 的颜色作为键的默认颜色

            const createLine = (x1, y1, x2, y2, strokeWidth = BOND_STROKE_WIDTH, strokeColor = bondColor, dashArray = null) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', strokeColor);
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke-linecap', 'round');
                if (dashArray) {
                    line.setAttribute('stroke-dasharray', dashArray);
                }
                svg.appendChild(line);
            };

            // 3. 楔形键绘制函数 (虚楔形键的画法已调整为更逼真的梯形虚线)
            const createWedge = (x1, y1, x2, y2, type, fillColor = bondColor) => {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const perpAngle = angle + Math.PI / 2;
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                if (type === 'wedge-up') {
                    const offset = WEDGE_WIDTH / 2;
                    const endOffX = offset * Math.cos(perpAngle);
                    const endOffY = offset * Math.sin(perpAngle);

                    const p1 = `${x1},${y1}`;
                    const p2 = `${x2 + endOffX},${y2 + endOffY}`;
                    const p3 = `${x2 - endOffX},${y2 - endOffY}`;

                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', `${p1} ${p2} ${p3}`);
                    polygon.setAttribute('fill', fillColor);
                    polygon.setAttribute('stroke', 'none');
                    g.appendChild(polygon);
                } else if (type === 'wedge-down') {
                    const dashLength = 3;
                    const dashGap = 1.5;
                    let currentDist = 0;

                    // 绘制虚线的梯形段
                    while (currentDist < dist) {
                        const startRatio = currentDist / dist;
                        const endRatio = Math.min(1, (currentDist + dashLength) / dist);

                        const startWidth = WEDGE_WIDTH * (1 - startRatio); // 虚楔形键从宽到窄
                        const endWidth = WEDGE_WIDTH * (1 - endRatio);

                        const perpOffset1_start = { x: (startWidth / 2) * Math.cos(perpAngle), y: (startWidth / 2) * Math.sin(perpAngle) };
                        const perpOffset1_end = { x: (endWidth / 2) * Math.cos(perpAngle), y: (endWidth / 2) * Math.sin(perpAngle) };

                        const perpOffset2_start = { x: -(startWidth / 2) * Math.cos(perpAngle), y: -(startWidth / 2) * Math.sin(perpAngle) };
                        const perpOffset2_end = { x: -(endWidth / 2) * Math.cos(perpAngle), y: -(endWidth / 2) * Math.sin(perpAngle) };

                        const seg_x1 = x2 - startRatio * dx + perpOffset1_start.x; // 从x2点向x1点倒推
                        const seg_y1 = y2 - startRatio * dy + perpOffset1_start.y;
                        const seg_x2 = x2 - endRatio * dx + perpOffset1_end.x;
                        const seg_y2 = y2 - endRatio * dy + perpOffset1_end.y;

                        const seg_x3 = x2 - startRatio * dx + perpOffset2_start.x;
                        const seg_y3 = y2 - startRatio * dy + perpOffset2_start.y;
                        const seg_x4 = x2 - endRatio * dx + perpOffset2_end.x;
                        const seg_y4 = y2 - endRatio * dy + perpOffset2_end.y;

                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', `${seg_x1},${seg_y1} ${seg_x2},${seg_y2} ${seg_x4},${seg_y4} ${seg_x3},${seg_y3}`);
                        polygon.setAttribute('fill', fillColor);
                        polygon.setAttribute('stroke', 'none');
                        g.appendChild(polygon);

                        currentDist += dashLength + dashGap;
                    }
                }
                svg.appendChild(g);
            };

            // 1. 绘制键
            bonds.forEach(b => {
                const a1 = atomMap.get(b.a1);
                const a2 = atomMap.get(b.a2);
                if (!a1 || !a2) return;

                const dx_total = a2.x - a1.x;
                const dy_total = a2.y - a1.y;
                const dist_total = Math.sqrt(dx_total * dx_total + dy_total * dy_total);
                const angle = Math.atan2(dy_total, dx_total);
                const perpAngle = angle + Math.PI / 2;

                let startOffset = 0;
                let endOffset = 0;
                // 仅对非C原子应用偏移
                if (a1.elem !== 'C') {
                    startOffset = BOND_END_OFFSET;
                }
                if (a2.elem !== 'C') {
                    endOffset = BOND_END_OFFSET;
                }
                const dist = dist_total - startOffset - endOffset;
                if (dist <= 0) return;

                const startX = a1.x + startOffset * Math.cos(angle);
                const startY = a1.y + startOffset * Math.sin(angle);
                const endX = a2.x - endOffset * Math.cos(angle);
                const endY = a2.y - endOffset * Math.sin(angle);

                // 绘制点击热区 (始终在底层)
                const hotspot = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hotspot.setAttribute('x1', startX);
                hotspot.setAttribute('y1', startY);
                hotspot.setAttribute('x2', endX);
                hotspot.setAttribute('y2', endY);
                hotspot.setAttribute('class', `selectable-bond${selectedBonds.has(b.id) ? ' selected' : ''}`);
                hotspot.setAttribute('data-bond-id', b.id);
                svg.appendChild(hotspot);

                const strokeColor = selectedBonds.has(b.id) ? 'rgb(255, 255, 0)' : bondColor; // 键的高亮颜色
                const offset = BOND_TYPE_OFFSET;

                if (b.type === 'double') {
                    const offX = offset * Math.cos(perpAngle);
                    const offY = offset * Math.sin(perpAngle);
                    createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                    createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                } else if (b.type === 'triple') {
                    const offX = offset * Math.cos(perpAngle);
                    const offY = offset * Math.sin(perpAngle);
                    createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                    createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                    createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                } else if (b.type === 'wedge-up' || b.type === 'wedge-down') {
                    createWedge(startX, startY, endX, endY, b.type, strokeColor);
                } else {
                    createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                }
            });

            // 2. 绘制原子
            atoms.forEach(a => {
                const shouldDrawSymbol = !(a.elem === 'C' && bondCount[a.id] > 0);

                // 绘制可点击的透明区域
                const clickableCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                clickableCircle.setAttribute('cx', a.x);
                clickableCircle.setAttribute('cy', a.y);
                clickableCircle.setAttribute('r', ATOM_RADIUS);
                clickableCircle.setAttribute('class', `selectable-atom${selectedAtoms.has(a.id) ? ' selected' : ''}`);
                clickableCircle.setAttribute('data-atom-id', a.id);
                svg.appendChild(clickableCircle);

                if (shouldDrawSymbol) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', a.x);
                    text.setAttribute('y', a.y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', getCssColor(a.elem)); // 使用 CSS 变量获取颜色
                    text.setAttribute('font-size', ATOM_FONT_SIZE);
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = a.elem;
                    text.setAttribute('data-atom-id', a.id);
                    svg.appendChild(text);
                }
            });

            // 3. 绘制选择框
            if (isSelecting && selectionRect) {
                svg.appendChild(selectionRect);
            }
        }

        // --- 省略不变的分子操作和事件逻辑 ---

        function addAtom(elem, x, y) {
            const newAtom = {
                id: nextAtomId++,
                elem,
                x,
                y
            };
            atoms.push(newAtom);
            draw();
        }

        function addBond(id1, id2) {
            const existingBondIndex = bonds.findIndex(b =>
                (b.a1 === id1 && b.a2 === id2) || (b.a1 === id2 && b.a2 === id1)
            );

            if (existingBondIndex !== -1) {
                if (currentBond === 'single') {
                    const existingBond = bonds[existingBondIndex];
                    if (existingBond.type === 'single') {
                        existingBond.type = 'double';
                    } else if (existingBond.type === 'double') {
                        existingBond.type = 'triple';
                    } else if (existingBond.type === 'triple') {
                        existingBond.type = 'single';
                    } else {
                        existingBond.type = 'single';
                    }
                } else {
                    bonds[existingBondIndex].type = currentBond;
                }
            } else {
                bonds.push({
                    id: nextBondId++,
                    a1: id1,
                    a2: id2,
                    type: currentBond
                });
            }
            draw();
        }

        function extendFrom(atomId, mouseX, mouseY) {
            const parentAtom = atoms.find(a => a.id === atomId);
            if (!parentAtom) return;

            const dx = mouseX - parentAtom.x;
            const dy = mouseY - parentAtom.y;
            let angle = Math.atan2(dy, dx);
            if (angle < 0) {
                angle += 2 * Math.PI;
            }

            const bondAngles = [
                0, Math.PI / 6, Math.PI / 3, Math.PI / 2, 2 * Math.PI / 3, 5 * Math.PI / 6, Math.PI,
                7 * Math.PI / 6, 4 * Math.PI / 3, 3 * Math.PI / 2, 5 * Math.PI / 3, 11 * Math.PI / 6, 2 * Math.PI
            ];

            let closestAngle = bondAngles[0];
            let minDiff = Math.abs(angle - closestAngle);
            for (let i = 1; i < bondAngles.length; i++) {
                const diff = Math.abs(angle - bondAngles[i]);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestAngle = bondAngles[i];
                }
            }

            const dist = 40;
            const newX = parentAtom.x + dist * Math.cos(closestAngle);
            const newY = parentAtom.y + dist * Math.sin(closestAngle);

            const overlappingAtom = atoms.find(a =>
                Math.sqrt(Math.pow(newX - a.x, 2) + Math.pow(newY - a.y, 2)) < ATOM_RADIUS
            );

            if (overlappingAtom) {
                addBond(parentAtom.id, overlappingAtom.id);
            } else {
                const newAtomId = nextAtomId;
                addAtom(currentTool, newX, newY);
                addBond(parentAtom.id, newAtomId);
            }
        }

        function toggleSelectAtom(atomId) {
            if (selectedAtoms.has(atomId)) {
                selectedAtoms.delete(atomId);
            } else {
                selectedAtoms.add(atomId);
            }
            draw();
        }

        function toggleSelectBond(bondId) {
            if (selectedBonds.has(bondId)) {
                selectedBonds.delete(bondId);
            } else {
                selectedBonds.add(bondId);
            }
            draw();
        }

        function clearSelection() {
            selectedAtoms.clear();
            selectedBonds.clear();
            if (selectionRect && selectionRect.parentNode) {
                selectionRect.parentNode.removeChild(selectionRect);
            }
            selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };
            draw();
        }

        function isInsideSelectionBox(x, y) {
            const padding = 5;
            if (selectedAtoms.size === 0) return false;
            if (selectionBox.right - selectionBox.left === 0 || selectionBox.bottom - selectionBox.top === 0) return false;

            return x >= selectionBox.left - padding && x <= selectionBox.right + padding &&
                y >= selectionBox.top - padding && y <= selectionBox.bottom + padding;
        }

        function getMousePos(e) {
            const rect = svg.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function updateCanvasCursor() {
            svg.classList.remove('move-cursor', 'lasso-cursor');
            if (mode === 'move') {
                svg.classList.add('move-cursor');
            } else if (mode === 'lasso') {
                svg.classList.add('lasso-cursor');
            } else {
                svg.style.cursor = 'crosshair';
            }
        }

        function deleteSelectedElements() {
            const atomsToDelete = new Set(selectedAtoms);
            const bondsToDelete = new Set(selectedBonds);

            if (atomsToDelete.size === 0 && bondsToDelete.size === 0) return;

            bonds.forEach(b => {
                if (atomsToDelete.has(b.a1) || atomsToDelete.has(b.a2)) {
                    bondsToDelete.add(b.id);
                }
            });

            bonds = bonds.filter(b => !bondsToDelete.has(b.id));
            atoms = atoms.filter(a => !atomsToDelete.has(a.id));

            clearSelection();
        }

        // ... 省略不变的 mousedown, mousemove, mouseup, mouseleave, keydown 事件处理 ...

        svg.addEventListener('mousedown', e => {
            const pos = getMousePos(e);
            dragStartPos = pos;
            const targetElem = e.target;
            const atomId = targetElem.getAttribute('data-atom-id');
            const bondId = targetElem.getAttribute('data-bond-id');

            if (mode === 'lasso') {
                if (selectedAtoms.size > 0 && isInsideSelectionBox(pos.x, pos.y)) {
                    isDraggingSelection = true;
                    if (selectionRect && selectionRect.parentNode) {
                        selectionRect.parentNode.removeChild(selectionRect);
                    }
                } else {
                    isSelecting = true;
                    startX = pos.x;
                    startY = pos.y;
                    if (selectionRect && selectionRect.parentNode) {
                        selectionRect.parentNode.removeChild(selectionRect);
                    }
                    selectionRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    selectionRect.setAttribute('id', 'selectionRect');
                    selectionRect.setAttribute('x', startX);
                    selectionRect.setAttribute('y', startY);
                    selectionRect.setAttribute('width', 0);
                    selectionRect.setAttribute('height', 0);
                    svg.appendChild(selectionRect);
                    clearSelection();
                }
            } else if (mode === 'move') {
                if (atomId) {
                    const id = parseInt(atomId);
                    if (!selectedAtoms.has(id)) {
                        clearSelection();
                        toggleSelectAtom(id);
                    }
                    isDraggingAtom = true;
                    dragTargetId = id;
                    const atom = atoms.find(a => a.id === dragTargetId);
                    dragStartOffset.x = pos.x - atom.x;
                    dragStartOffset.y = pos.y - atom.y;
                } else if (bondId) {
                    clearSelection();
                    toggleSelectBond(parseInt(bondId));
                } else {
                    clearSelection();
                }
            } else { // mode === 'draw'
                if (atomId) {
                    isDraggingAtom = true;
                    dragTargetId = parseInt(atomId);
                } else if (bondId) {
                    const bond = bonds.find(b => b.id === parseInt(bondId));
                    if (bond) {
                        if (currentBond === 'single') {
                            if (bond.type === 'single') bond.type = 'double';
                            else if (bond.type === 'double') bond.type = 'triple';
                            else if (bond.type === 'triple') bond.type = 'single';
                            else bond.type = 'single';
                        } else {
                            bond.type = currentBond;
                        }
                        draw();
                    }
                } else if (e.target.tagName === 'svg') {
                    addAtom(currentTool, pos.x, pos.y);
                    clearSelection();
                }
            }
        });

        svg.addEventListener('mousemove', e => {
            const pos = getMousePos(e);

            if (isDraggingSelection) {
                const dx = pos.x - dragStartPos.x;
                const dy = pos.y - dragStartPos.y;

                selectedAtoms.forEach(id => {
                    const atom = atoms.find(a => a.id === id);
                    if (atom) {
                        atom.x += dx;
                        atom.y += dy;
                    }
                });

                selectionBox.left += dx;
                selectionBox.right += dx;
                selectionBox.top += dy;
                selectionBox.bottom += dy;

                dragStartPos = pos;
                draw();
                return;
            }

            if (mode === 'lasso' && isSelecting) {
                const width = Math.abs(pos.x - startX);
                const height = Math.abs(pos.y - startY);
                const newX = Math.min(pos.x, startX);
                const newY = Math.min(pos.y, startY);
                selectionRect.setAttribute('x', newX);
                selectionRect.setAttribute('y', newY);
                selectionRect.setAttribute('width', width);
                selectionRect.setAttribute('height', height);
            } else if (mode === 'move' && isDraggingAtom) {
                const atom = atoms.find(a => a.id === dragTargetId);
                if (atom) {
                    atom.x = pos.x - dragStartOffset.x;
                    atom.y = pos.y - dragStartOffset.y;
                    draw();
                }
            } else {
                svg.querySelectorAll('.hover-effect').forEach(el => el.remove());
                const targetElem = e.target;
                const atomId = targetElem.getAttribute('data-atom-id');
                const bondId = targetElem.getAttribute('data-bond-id');
                const atomMapForHover = new Map(atoms.map(a => [a.id, a]));

                if (atomId && !selectedAtoms.has(parseInt(atomId))) {
                    const atom = atoms.find(a => a.id === parseInt(atomId));
                    if (atom) {
                        const hoverCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        hoverCircle.setAttribute('cx', atom.x);
                        hoverCircle.setAttribute('cy', atom.y);
                        hoverCircle.setAttribute('r', ATOM_RADIUS + 2);
                        hoverCircle.setAttribute('stroke', HOVER_COLOR);
                        hoverCircle.setAttribute('stroke-width', 2);
                        hoverCircle.setAttribute('fill', 'none');
                        hoverCircle.setAttribute('class', 'hover-effect');
                        svg.appendChild(hoverCircle);
                    }
                } else if (bondId && !selectedBonds.has(parseInt(bondId))) {
                    const bond = bonds.find(b => b.id === parseInt(bondId));
                    if (bond) {
                        const a1 = atomMapForHover.get(bond.a1);
                        const a2 = atomMapForHover.get(bond.a2);
                        if (!a1 || !a2) return;
                        const hoverLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hoverLine.setAttribute('x1', a1.x);
                        hoverLine.setAttribute('y1', a1.y);
                        hoverLine.setAttribute('x2', a2.x);
                        hoverLine.setAttribute('y2', a2.y);
                        hoverLine.setAttribute('stroke', HOVER_COLOR);
                        hoverLine.setAttribute('stroke-width', 8);
                        hoverLine.setAttribute('class', 'hover-effect');
                        svg.appendChild(hoverLine);
                    }
                }
            }
        });

        svg.addEventListener('mouseup', e => {
            const pos = getMousePos(e);
            dragEndPos = pos;
            const dragDistance = Math.sqrt(Math.pow(dragEndPos.x - dragStartPos.x, 2) + Math.pow(dragEndPos.y - dragStartPos.y, 2));

            if (isDraggingSelection) {
                isDraggingSelection = false;
                draw();
                return;
            }

            if (mode === 'lasso') {
                isSelecting = false;
                if (selectionRect) {
                    svg.removeChild(selectionRect);
                    selectionRect = null;
                }

                if (dragDistance > CLICK_THRESHOLD) {
                    const endX = pos.x;
                    const endY = pos.y;
                    const left = Math.min(startX, endX);
                    const top = Math.min(startY, endY);
                    const width = Math.abs(startX - endX);
                    const height = Math.abs(startY - endY);

                    selectionBox.left = left;
                    selectionBox.top = top;
                    selectionBox.right = left + width;
                    selectionBox.bottom = top + height;

                    atoms.forEach(a => {
                        if (a.x >= left && a.x <= left + width && a.y >= top && a.y <= top + height) {
                            selectedAtoms.add(a.id);
                        }
                    });
                    bonds.forEach(b => {
                        const a1 = atoms.find(a => a.id === b.a1);
                        const a2 = atoms.find(a => a.id === b.a2);
                        if (!a1 || !a2) return;
                        if (selectedAtoms.has(a1.id) && selectedAtoms.has(a2.id)) {
                            selectedBonds.add(b.id);
                        }
                    });
                } else {
                    if (!isInsideSelectionBox(pos.x, pos.y)) {
                        clearSelection();
                    }
                }
                draw();
            } else if (mode === 'move') {
                isDraggingAtom = false;
                dragTargetId = null;
                draw();
            } else if (mode === 'draw' && isDraggingAtom) {
                if (dragDistance < CLICK_THRESHOLD) {
                    const targetAtom = atoms.find(a => a.id === dragTargetId);
                    if (targetAtom) {
                        targetAtom.elem = currentTool;
                    }
                } else {
                    const targetAtom = atoms.find(a => a.id !== dragTargetId && Math.sqrt(Math.pow(pos.x - a.x, 2) + Math.pow(pos.y - a.y, 2)) < ATOM_RADIUS);
                    if (targetAtom) {
                        addBond(dragTargetId, targetAtom.id);
                    } else {
                        extendFrom(dragTargetId, pos.x, pos.y);
                    }
                }
                isDraggingAtom = false;
                dragTargetId = null;
                draw();
            }

            const mouseEvent = new MouseEvent('mousemove', {
                clientX: e.clientX,
                clientY: e.clientY
            });
            svg.dispatchEvent(mouseEvent);
        });

        svg.addEventListener('mouseleave', () => {
            isSelecting = false;
            isDraggingAtom = false;
            isDraggingSelection = false;
            dragTargetId = null;
            if (selectionRect) {
                svg.removeChild(selectionRect);
                selectionRect = null;
            }
            svg.querySelectorAll('.hover-effect').forEach(el => el.remove());
        });

        document.addEventListener('keydown', e => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                deleteSelectedElements();
            }
        });


        // --- PNG 导出逻辑（修正：排除热点和原子圆形，确保符号/键线颜色） ---
        document.getElementById('exportPngBtn').addEventListener('click', () => {
            const svgElement = document.getElementById('svg');

            clearSelection();
            svgElement.querySelectorAll('.hover-effect').forEach(el => el.remove());

            let bbox;
            try {
                bbox = svgElement.getBBox();
                if (bbox.width === 0 || bbox.height === 0) {
                    alert('画布为空，无法导出！');
                    return;
                }
            } catch (e) {
                alert('画布为空或浏览器不支持，无法导出！');
                return;
            }

            const margin = 15;
            const width = bbox.width + 2 * margin;
            const height = bbox.height + 2 * margin;

            const translateX = -bbox.x + margin;
            const translateY = -bbox.y + margin;

            const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            tempSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            tempSvg.setAttribute('width', width);
            tempSvg.setAttribute('height', height);
            tempSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${translateX}, ${translateY})`);

            // 只克隆实际可见的绘图元素（排除热点 selectable-atom/selectable-bond 和 hover-effect）
            Array.from(svgElement.children).forEach(child => {
                // 跳过选择框
                if (child.id === 'selectionRect') return;

                const cls = child.getAttribute('class') || '';

                // 排除原子圆形热点、键热点、悬停效果等（这些在临时 svg 中会变成黑色）
                if (cls.includes('selectable-atom') || cls.includes('selectable-bond') || cls.includes('hover-effect')) {
                    return;
                }

                // 克隆并修正必要属性
                const clonedChild = child.cloneNode(true);

                // 文本：确保填充为该原子的计算颜色
                if (clonedChild.tagName === 'text') {
                    const atomId = clonedChild.getAttribute('data-atom-id');
                    const atom = atoms.find(a => a.id === parseInt(atomId));
                    if (atom) {
                        clonedChild.setAttribute('fill', getCssColor(atom.elem));
                    }
                }

                // 线段：如果无 stroke，设置默认键颜色
                if (clonedChild.tagName === 'line') {
                    const stroke = clonedChild.getAttribute('stroke');
                    if (!stroke) {
                        clonedChild.setAttribute('stroke', getCssColor('C'));
                    }
                }

                // 多边形或组：确保内部 polygon 等有 fill（createWedge 已设置 fill，一般无需修改）
                if (clonedChild.tagName === 'g' || clonedChild.tagName === 'polygon' || clonedChild.tagName === 'path') {
                    // 对于 group，确保其子元素的 fill/stroke 存在（逐子元素设置以防遗漏）
                    if (clonedChild.tagName === 'g') {
                        Array.from(clonedChild.querySelectorAll('*')).forEach(ch => {
                            if ((ch.tagName === 'polygon' || ch.tagName === 'path') && !ch.getAttribute('fill')) {
                                ch.setAttribute('fill', getCssColor('C'));
                            }
                            if (ch.tagName === 'line' && !ch.getAttribute('stroke')) {
                                ch.setAttribute('stroke', getCssColor('C'));
                            }
                        });
                    } else {
                        if ((clonedChild.tagName === 'polygon' || clonedChild.tagName === 'path') && !clonedChild.getAttribute('fill')) {
                            clonedChild.setAttribute('fill', getCssColor('C'));
                        }
                    }
                }

                g.appendChild(clonedChild);
            });

            tempSvg.appendChild(g);

            const svgData = new XMLSerializer().serializeToString(tempSvg);

            const img = new Image();
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            img.onload = function () {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // 设置透明背景
                ctx.clearRect(0, 0, width, height);

                ctx.drawImage(img, 0, 0);

                const dataURL = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = 'molecular_structure_transparent.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            };
            img.src = url;
        });

        // --- 新增：CSV 导出逻辑 ---
        function mapBondSymbol(type) {
            if (!type) return '-';
            const t = type.toLowerCase();
            if (t === 'single') return '-';
            if (t === 'double') return '=';
            if (t === 'triple') return '#';
            if (t === 'aromatic' || t === 'a') return 'A';
            // 楔形或其他类型默认视为单键显示 '-'
            return '-';
        }

        function buildAdjacencyCsv(bondsList) {
            const lines = [];
            lines.push('SeqA,SeqB,BondSym');
            bondsList.forEach(b => {
                const a1 = (typeof b.a1 === 'number') ? b.a1 : parseInt(b.a1);
                const a2 = (typeof b.a2 === 'number') ? b.a2 : parseInt(b.a2);
                const sym = mapBondSymbol(b.type);
                lines.push(`${a1},${a2},${sym}`);
            });
            return lines.join('\n');
        }

        function buildAtomCsv(atomsList) {
            const lines = [];
            lines.push('Seq,Symbol');
            // 按 id 升序确保顺序一致
            const sorted = atomsList.slice().sort((x, y) => x.id - y.id);
            sorted.forEach(a => {
                lines.push(`${a.id},${a.elem}`);
            });
            return lines.join('\n');
        }

        function downloadCsv(filename, content) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        document.getElementById('exportCsvBtn').addEventListener('click', () => {
            if (!atoms || atoms.length === 0) {
                alert('画布为空，无法导出 CSV！');
                return;
            }

            // 先清理可视辅助元素，确保导出一致
            clearSelection();
            svg.querySelectorAll('.hover-effect').forEach(el => el.remove());

            const adjCsv = buildAdjacencyCsv(bonds);
            const atomCsv = buildAtomCsv(atoms);

            // 先导出邻接表，再导出原子表
            downloadCsv('ADJ_DRAW.csv', adjCsv);
            // 延迟一下触发第二个下载以避免某些浏览器限制（短暂异步）
            setTimeout(() => {
                downloadCsv('ATOM_DRAW.csv', atomCsv);
            }, 50);
        });

        // --- 工具栏按钮逻辑 ---
        document.querySelectorAll('#toolbar button').forEach(btn => {
            btn.addEventListener('click', () => {

                if (btn.id === 'deleteBtn' || btn.id === 'exportPngBtn') {
                    if (btn.id === 'deleteBtn') deleteSelectedElements();
                    // 导出按钮逻辑已在上方实现
                    return;
                }

                clearSelection();

                if (btn.classList.contains('mode-btn')) {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    mode = btn.id === 'drawBtn' ? 'draw' : btn.id === 'moveBtn' ? 'move' : 'lasso';
                } else if (btn.classList.contains('atom-btn')) {
                    document.querySelectorAll('.atom-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    document.getElementById('drawBtn').click();
                } else if (btn.classList.contains('bond-btn')) {
                    document.querySelectorAll('.bond-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentBond = btn.dataset.bond;
                    document.getElementById('drawBtn').click();
                }
                updateCanvasCursor();
            });
        });


        // 初始设置默认工具
        document.getElementById('drawBtn').click();
        document.querySelector('.atom-btn[data-tool="C"]').classList.add('active');
        document.querySelector('.bond-btn[data-bond="single"]').classList.add('active');

        // 确保页面加载后至少有一个初始原子
        //if (atoms.length === 0) {
        //    addAtom('C', 50, 50);
        //}

        draw();

        // --- JavaScript End ---
    </script>
</body>
</html>