<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>有机分子结构绘制与3D可视化工具</title>

    <!-- 全局和布局样式 -->
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #20232A; /* 使用Draw.html的深色背景作为全局背景 */
        }

        #main-container {
            display: flex;
            height: 100%;
            width: 100%;
        }

        #draw-container, #d3-container {
            height: 100%;
            position: relative;
            overflow: hidden; /* 隐藏内部溢出 */
        }

        /* 修正 #1：让draw-container内部元素水平排列 */
        #draw-container {
            width: 50%;
            min-width: 300px; /* 最小宽度 */
            display: flex;
            flex-direction: row;
        }

        #d3-container {
            flex: 1; /* 占据剩余空间 */
            min-width: 400px; /* 最小宽度 */
        }

        #resizer {
            width: 8px;
            height: 100%;
            background-color: #3C424F;
            cursor: col-resize;
            flex-shrink: 0;
            z-index: 200;
        }
    </style>

    <!-- Draw.html 的样式 (已用 #draw-container 作用域限定) -->
    <style>
        #draw-container {
            --bg-dark: #20232A;
            --toolbar-bg: #282C34;
            --canvas-bg: #FFFFFF;
            --border-color: #3C424F;
            --text-color-light: #F8F8F8;
            --active-bg: #3C424F;
            --hover-bg: #4A515F;
            --atom-color: #61AFEF;
            --bond-color: #98C379;
            --mode-color: #C678DD;
            --delete-color: #E06C75;
            --export-color: #FFD700;
            --color-C: #282C34;
            --color-H: #A9A9A9;
            --color-O: #87CEFA;
            --color-N: #FFD700;
            --color-S: #FFB6C1;
        }

            #draw-container #toolbar {
                width: 120px;
                background: var(--toolbar-bg);
                padding: 10px 10px;
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                gap: 10px;
                overflow-y: auto;
                box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
                flex-shrink: 0;
            }

            #draw-container .button-group {
                display: flex;
                flex-direction: column;
                gap: 5px;
                padding-bottom: 5px;
            }

            #draw-container .divider {
                height: 1px;
                background: var(--border-color);
                margin: 5px 0;
            }

            #draw-container .section-title {
                font-size: 10px;
                color: #9DA5B4;
                text-transform: uppercase;
                margin-bottom: 5px;
                text-align: center;
            }

            #draw-container button {
                width: 100%;
                padding: 5px 3px;
                font-size: 12px;
                line-height: 1.2;
                background: transparent;
                border: 1px solid var(--border-color);
                color: var(--text-color-light);
                cursor: pointer;
                border-radius: 4px;
                transition: all 0.2s ease-in-out;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                display: flex;
                align-items: center;
                justify-content: center;
            }

                #draw-container button:hover {
                    background: var(--hover-bg);
                    border-color: var(--hover-bg);
                    color: var(--text-color-light);
                }

                #draw-container button.active {
                    background: var(--active-bg);
                    border-color: var(--active-bg);
                    box-shadow: 0 0 5px rgba(97, 175, 239, 0.5);
                }

            #draw-container .atom-btn.active {
                color: var(--atom-color);
                border-color: var(--atom-color);
            }

            #draw-container .bond-btn.active {
                color: var(--bond-color);
                border-color: var(--bond-color);
            }

            #draw-container .mode-btn.active {
                color: var(--mode-color);
                border-color: var(--mode-color);
            }

            #draw-container #exportPngBtn {
                background: var(--export-color);
                border-color: var(--export-color);
                color: var(--color-C);
                font-weight: bold;
                margin-top: 10px;
            }

                #draw-container #exportPngBtn:hover {
                    background: #D4AF37;
                    border-color: #D4AF37;
                }

            #draw-container #exportCsvBtn {
                background: #FFE599;
                border-color: #FFE599;
                color: var(--color-C);
                font-weight: bold;
                margin-top: 5px;
            }

                #draw-container #exportCsvBtn:hover {
                    background: #FFEB9C;
                    border-color: #FFEB9C;
                }

            #draw-container #deleteBtn {
                background: var(--delete-color);
                border-color: var(--delete-color);
                font-weight: bold;
                margin-top: 5px;
            }

                #draw-container #deleteBtn:hover {
                    background: #B94451;
                    border-color: #B94451;
                }

            #draw-container .wedge-icon {
                width: 16px;
                height: 10px;
                overflow: visible;
            }

            #draw-container #canvas-wrapper {
                flex: 1;
                background: var(--canvas-bg);
                overflow: hidden;
            }

            #draw-container svg {
                width: 100%;
                height: 100%;
                cursor: crosshair;
            }

                #draw-container svg .selectable-atom {
                    stroke: transparent;
                    fill: transparent;
                    stroke-width: 2;
                    cursor: pointer;
                }

                    #draw-container svg .selectable-atom.selected {
                        stroke: #FFD700;
                        stroke-width: 3;
                        fill: rgba(255, 255, 0, 0.1);
                    }

                #draw-container svg .selectable-bond {
                    stroke: transparent;
                    stroke-width: 10;
                    cursor: pointer;
                }

                    #draw-container svg .selectable-bond.selected {
                        stroke: #FFD700;
                    }

                #draw-container svg text {
                    user-select: none;
                    pointer-events: none;
                }

            #draw-container #selectionRect {
                fill: rgba(100, 150, 255, 0.1);
                stroke: #61AFEF;
                stroke-width: 1;
                stroke-dasharray: 4, 2;
            }
    </style>

    <!-- 3D_V3.html 的样式 (已用 #d3-container 作用域限定) -->
    <style>
        #d3-container {
            /* --- 配色方案 (降低饱和度) --- */
            --color-load-light: #FFC09F; /* 浅橙/杏色 */
            --color-light-light: #F0B7C6; /* 浅粉/紫丁香 */
            --color-params-light: #B6E0C7; /* 浅绿/薄荷 */
            --color-export-light: #B0D6F5; /* 浅蓝/天空 */
            --color-text-dark: #DDDDDD; /* 暗背景下的文字颜色 */
            --color-load-dark: #D48060;
            --color-light-dark: #C47A9A;
            --color-params-dark: #86A890;
            --color-export-dark: #7096B0;
            --color-text-light: #333333; /* 亮背景下的文字颜色 */
            --current-text-color: var(--color-text-dark);
            --current-load-color: var(--color-load-light);
            --current-light-color: var(--color-light-light);
            --current-params-color: var(--color-params-light);
            --current-export-color: var(--color-export-light);
            --current-toggle-active: var(--color-params-light);
            --axis-x-color: #D62828;
            --axis-y-color: #008000;
            --axis-z-color: #0000FF;
            --axis-text-color: #FFFFFF;
        }

        #d3-container {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* 内部滚动由body改为这个容器 */
            background-color: #000000;
        }

            #d3-container canvas {
                display: block;
            }

            #d3-container #controls-container-wrapper {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 100;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                line-height: 1.2;
                transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            #d3-container .control-panel {
                padding: 10px;
                margin-bottom: 10px;
                background: rgba(240, 240, 240, 0.35);
                backdrop-filter: blur(5px);
                border-radius: 12px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.15);
                width: 200px;
                box-sizing: border-box;
                color: var(--current-text-color);
            }

                #d3-container .control-panel h3 {
                    margin-top: 0;
                    margin-bottom: 8px;
                    font-size: 15px;
                    font-weight: 600;
                    color: var(--current-load-color);
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    padding-bottom: 4px;
                }

            #d3-container .control-group {
                margin-bottom: 8px;
            }

                #d3-container .control-group label {
                    color: var(--current-text-color);
                    font-size: 13px;
                    margin-bottom: 2px;
                    display: block;
                }

            #d3-container input[type="file"] {
                color: var(--current-text-color);
                font-size: 12px;
                margin-bottom: 8px;
                display: block;
                width: 100%;
                box-sizing: border-box;
                padding: 4px 0;
                border: none;
                background: none;
            }

            #d3-container #status-message {
                font-size: 13px;
                margin-top: 5px;
                margin-bottom: 0;
                line-height: 1.2;
                color: var(--current-load-color);
            }

            #d3-container button {
                padding: 5px 10px;
                cursor: pointer;
                box-sizing: border-box;
                margin-top: 5px;
                border: none;
                border-radius: 8px;
                font-weight: 600;
                transition: all 0.2s;
                box-shadow: 0 3px 0 0 rgba(0, 0, 0, 0.2);
                color: #333;
            }

                #d3-container button:hover {
                    opacity: 0.9;
                    transform: translateY(-1px);
                    box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.2);
                }

                #d3-container button:active {
                    transform: translateY(2px);
                    box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.2);
                }

            #d3-container #render-buttons {
                display: flex;
                gap: 6px;
                margin-top: 8px;
            }

                #d3-container #render-buttons button {
                    width: 50%;
                    background-color: var(--current-load-color);
                }

            #d3-container #light-presets {
                display: flex;
                gap: 6px;
                margin-top: 8px;
            }

                #d3-container #light-presets button {
                    width: 50%;
                    background-color: var(--current-light-color);
                }

            #d3-container #export-controls-panel button {
                width: 100%;
                background-color: var(--current-export-color);
            }

            #d3-container .light-control-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 5px;
                color: var(--current-text-color);
            }

            #d3-container #hydrogen-toggle-group {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
            }

                #d3-container #hydrogen-toggle-group label:first-child {
                    display: inline;
                    margin-bottom: 0;
                }

            #d3-container .light-control-row input[type="range"] {
                width: 100%;
                height: 4px;
                -webkit-appearance: none;
                background: rgba(255, 255, 255, 0.5);
                border: 1px solid rgba(0, 0, 0, 0.2);
                border-radius: 5px;
                margin: 5px 0;
                box-shadow: none;
            }

                #d3-container .light-control-row input[type="range"]::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: var(--current-export-color);
                    cursor: pointer;
                    box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
                }

            #d3-container #background-picker-group-wrapper {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            #d3-container #background-color-picker-container {
                width: 25px;
                height: 18px;
                border: 1px solid var(--current-text-color);
                border-radius: 4px;
                margin-left: 5px;
                overflow: hidden;
                position: relative;
                cursor: pointer;
                transition: border-color 0.3s;
            }

            #d3-container #background-color-picker {
                width: 150%;
                height: 150%;
                position: absolute;
                top: -25%;
                left: -25%;
                padding: 0;
                border: none;
                cursor: pointer;
                opacity: 0;
            }

            #d3-container #background-picker-group {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            #d3-container .color-swatch {
                width: 20px;
                height: 20px;
                border: 1px solid var(--current-text-color);
                cursor: pointer;
                border-radius: 50%;
                transition: transform 0.1s;
            }

                #d3-container .color-swatch:hover {
                    transform: scale(1.1);
                    box-shadow: 0 0 5px var(--current-text-color);
                }

            #d3-container #highlight-info {
                position: absolute; /* Changed from fixed */
                bottom: 40px;
                left: 10px;
                z-index: 100;
                font-family: Arial, sans-serif;
                font-size: 14px;
                line-height: 1.4;
                padding: 5px;
                background: none;
                color: #FFFFFF;
                text-shadow: none;
            }

            #d3-container #toggle-button-wrapper {
                position: absolute; /* Changed from fixed */
                bottom: 10px;
                left: 10px;
                z-index: 101;
                font-family: Arial, sans-serif;
                font-size: 14px;
                display: flex;
                align-items: center;
                color: #FFFFFF;
                text-shadow: none;
            }

            #d3-container #controls-label {
                margin-right: 8px;
                white-space: nowrap;
            }

            #d3-container .toggle-switch {
                position: relative;
                display: inline-block;
                width: 64px;
                height: 20px;
            }

                #d3-container .toggle-switch input {
                    opacity: 0;
                    width: 0;
                    height: 0;
                }

            #d3-container .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #5A5A5A;
                transition: background-color .4s;
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0 6px;
                color: #E0E0E0;
                font-weight: 500;
                font-size: 11px;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4);
                text-shadow: none;
            }

                #d3-container .slider:before {
                    position: absolute;
                    content: "";
                    height: 14px;
                    width: 14px;
                    left: 3px;
                    bottom: 3px;
                    background-color: #FFFFFF;
                    transition: transform .4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                    border-radius: 50%;
                    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
                }

            #d3-container .toggle-switch input:checked + .slider {
                background-color: var(--current-toggle-active);
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
                color: #333;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider:before {
                transform: translateX(41px);
            }

            #d3-container .toggle-switch input:checked + .slider:before {
                transform: translateX(0);
            }

            #d3-container .slider-text-off {
                position: absolute;
                left: 6px;
                opacity: 1;
                transition: opacity .4s;
            }

            #d3-container .slider-text-on {
                position: absolute;
                right: 6px;
                opacity: 0;
                transition: opacity .4s;
            }

            #d3-container .toggle-switch input:checked + .slider .slider-text-off {
                opacity: 0;
            }

            #d3-container .toggle-switch input:checked + .slider .slider-text-on {
                opacity: 1;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider .slider-text-off {
                opacity: 1;
            }

            #d3-container .toggle-switch input:not(:checked) + .slider .slider-text-on {
                opacity: 0;
            }

            #d3-container #axis-renderer-container {
                position: absolute; /* Changed from fixed */
                top: 10px;
                left: 10px;
                width: 80px;
                height: 80px;
                z-index: 100;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            }

                #d3-container #axis-renderer-container canvas {
                    position: absolute;
                    top: 0;
                    left: 0;
                }
    </style>
</head>
<body>

    <div id="main-container">
        <!-- 左侧：Draw.html 内容 -->
        <div id="draw-container">
            <div id="toolbar">
                <div class="button-group">
                    <div class="section-title">原子 (Atom)</div>
                    <button data-tool="C" class="atom-btn active">C</button>
                    <button data-tool="H" class="atom-btn">H</button>
                    <button data-tool="O" class="atom-btn">O</button>
                    <button data-tool="N" class="atom-btn">N</button>
                    <button data-tool="S" class="atom-btn">S</button>
                </div>
                <div class="divider"></div>
                <div class="button-group">
                    <div class="section-title">键 (Bond)</div>
                    <button data-bond="single" class="bond-btn active">单键</button>
                    <button data-bond="double" class="bond-btn">双键</button>
                    <button data-bond="triple" class="bond-btn">三键</button>

                    <button data-bond="wedge-up" class="bond-btn" id="wedgeUpBtn">
                        <svg class="wedge-icon" viewBox="0 0 16 10">
                            <polygon points="0,5 16,10 16,0" fill="currentColor" />
                        </svg>
                    </button>
                    <button data-bond="wedge-down" class="bond-btn" id="wedgeDownBtn">
                        <svg class="wedge-icon" viewBox="0 0 16 10">
                            <g fill="currentColor">
                                <polygon points="0,5 5,6.5 5,3.5" />
                                <polygon points="6,3 11,8 11,2" />
                                <polygon points="12,1 16,9 16,1" />
                            </g>
                        </svg>
                    </button>
                </div>
                <div class="divider"></div>
                <div class="button-group">
                    <div class="section-title">功能 (Tool)</div>
                    <button id="drawBtn" class="mode-btn active">✏️ 构造</button>
                    <button id="moveBtn" class="mode-btn">🤚 移动</button>
                    <button id="lassoBtn" class="mode-btn">🔲 套索</button>

                    <button id="exportCsvBtn">📄 导出 CSV</button>
                    <button id="exportPngBtn">📷 导出 PNG</button>

                    <button id="deleteBtn">🗑️ 删除</button>
                </div>
            </div>
            <div id="canvas-wrapper">
                <svg id="draw-svg"></svg>
            </div>
        </div>

        <!-- 拖动条 -->
        <div id="resizer"></div>

        <!-- 右侧：3D_V3.html 内容 -->
        <div id="d3-container">
            <div id="axis-renderer-container"></div>
          
            <div id="highlight-info">
                <div>原子符号：<span id="highlight-symbol">无</span></div>
                <div>原子编号：<span id="highlight-index">--</span></div>
                <div>原子颜色：<span id="highlight-color">#--</span></div>
                <div>原子坐标：<span id="highlight-coords">----</span></div>
                <div>分子SMILES：<span id="smiles-result">--</span></div>
            </div>
            <div id="toggle-button-wrapper">
                <span id="controls-label">功能区:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="controls-toggle" checked>
                    <span class="slider">
                        <span class="slider-text-on">开</span>
                        <span class="slider-text-off">关</span>
                    </span>
                </label>
            </div>
            <div id="controls-container-wrapper">
                <div id="file-input-panel" class="control-panel">
                    <h3>分子数据加载</h3>
                    <label for="sxyz-file">SXYZ.csv:</label>
                    <input type="file" id="sxyz-file" accept=".csv">
                    <label for="adj-file">ADJ_AB.csv:</label>
                    <input type="file" id="adj-file" accept=".csv">
                    <div id="render-buttons">
                        <button class="load-button" onclick="d3App.loadAndDraw('ball_stick')">球棍模型</button>
                        <button class="load-button" onclick="d3App.loadAndDraw('stick')">棒状模型</button>
                    </div>
                    <p id="status-message"></p>
                </div>
                <div id="light-controls-panel" class="control-panel">
                    <h3>光照强度调节</h3>
                    <div class="control-group">
                        <label>环境光强度 (<span id="ambient-value">4.0</span>)</label>
                        <div class="light-control-row">
                            <input type="range" id="ambient-light-range" min="0.0" max="5.0" step="0.1" value="4.0">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>点光源强度 (<span id="directional-value">0.0</span>)</label>
                        <div class="light-control-row">
                            <input type="range" id="directional-light-range" min="0.0" max="2.0" step="0.1" value="0.0">
                        </div>
                    </div>
                    <div id="light-presets">
                        <button class="light-button" onclick="d3App.setLightPreset('clear')">清透</button>
                        <button class="light-button" onclick="d3App.setLightPreset('3d')">立体</button>
                    </div>
                </div>
                <div id="params-controls-panel" class="control-panel">
                    <h3>相关参数修改</h3>
                    <div class="control-group">
                        <label>背景颜色</label>
                        <div id="background-picker-group-wrapper">
                            <div id="background-color-picker-container" style="background-color: #000000;">
                                <input type="color" id="background-color-picker" value="#000000">
                            </div>
                            <div id="background-picker-group">
                                <div class="color-swatch" style="background-color: #000000;" data-color="#000000"></div>
                                <div class="color-swatch" style="background-color: #888888;" data-color="#888888"></div>
                                <div class="color-swatch" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                            </div>
                        </div>
                    </div>
                    <div class="control-group" id="hydrogen-toggle-group">
                        <label>显示氢原子</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="show-hydrogen" checked>
                            <span class="slider">
                                <span class="slider-text-on">是</span>
                                <span class="slider-text-off">否</span>
                            </span>
                        </label>
                    </div>
                </div>
                <div id="export-controls-panel" class="control-panel">
                    <h3>图片导出</h3>
                    <button class="export-button" onclick="d3App.exportView('png')">导出 PNG (无背景)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 依赖库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvg/3.0.10/canvg.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

    <!-- 拖动条脚本 -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const resizer = document.getElementById('resizer');
            const drawContainer = document.getElementById('draw-container');
            const d3Container = document.getElementById('d3-container');

            let isResizing = false;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';

                // 移除d3App的OrbitControls事件监听，防止拖动时旋转视角
                if (window.d3App && window.d3App.controls) {
                    window.d3App.controls.enabled = false;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const mainContainer = document.getElementById('main-container');
                const mainRect = mainContainer.getBoundingClientRect();

                let newDrawWidth = e.clientX - mainRect.left;

                const minDrawWidth = parseInt(getComputedStyle(drawContainer).minWidth, 10);
                const minD3Width = parseInt(getComputedStyle(d3Container).minWidth, 10);

                if (newDrawWidth < minDrawWidth) {
                    newDrawWidth = minDrawWidth;
                }

                if (mainRect.width - newDrawWidth - resizer.offsetWidth < minD3Width) {
                    newDrawWidth = mainRect.width - minD3Width - resizer.offsetWidth;
                }

                drawContainer.style.width = newDrawWidth + 'px';

                // 触发d3App的窗口大小调整函数
                if(window.d3App && typeof window.d3App.onWindowResize === 'function') {
                    window.d3App.onWindowResize();
                }
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.body.style.userSelect = 'auto';

                // 恢复d3App的OrbitControls
                if (window.d3App && window.d3App.controls) {
                    window.d3App.controls.enabled = true;
                }
            });
        });
    </script>

    <!-- Draw.html 脚本 (已封装) -->
    <script>
    (function() {
        // --- JavaScript Start ---
        const getCssColor = (elem) => {
            const style = getComputedStyle(document.querySelector('#draw-container'));
            return style.getPropertyValue(`--color-${elem}`).trim();
        };

        let atoms = [];
        let bonds = [];
        let selectedAtoms = new Set();
        let selectedBonds = new Set();
        let currentTool = 'C';
        let currentBond = 'single';
        let nextAtomId = 1; // ID从1开始，与3D视图匹配
        let nextBondId = 0;
        let mode = 'draw';
        let dragStartPos = { x: 0, y: 0 };
        let dragEndPos = { x: 0, y: 0 };
        let isDraggingAtom = false;
        let dragTargetId = null;
        let dragStartOffset = { x: 0, y: 0 };
        let isDraggingSelection = false;

        const svg = document.getElementById('draw-svg');
        const canvasWrapper = document.getElementById('canvas-wrapper');

        let isSelecting = false;
        let startX = 0;
        let startY = 0;
        let selectionRect;
        let selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };

        const ATOM_RADIUS = 10;
        const ATOM_FONT_SIZE = '14px';

        const BOND_STROKE_WIDTH = 2;
        const BOND_END_OFFSET = 10;
        const BOND_TYPE_OFFSET = 3;
        const WEDGE_WIDTH = 8;

        const HIGHLIGHT_COLOR = 'rgba(255, 255, 200, 0.5)';
        const HOVER_COLOR = 'rgba(97, 175, 239, 0.5)';
        const CLICK_THRESHOLD = 5;

        function draw() {
            svg.innerHTML = '';
            const atomMap = new Map(atoms.map(a => [a.id, a]));
            const bondCount = atoms.reduce((acc, atom) => {
                acc[atom.id] = bonds.filter(b => b.a1 === atom.id || b.a2 === atom.id).length;
                return acc;
            }, {});

            const bondColor = getCssColor('C');

            const createLine = (x1, y1, x2, y2, strokeWidth = BOND_STROKE_WIDTH, strokeColor = bondColor, dashArray = null) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', strokeColor);
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke-linecap', 'round');
                if (dashArray) {
                    line.setAttribute('stroke-dasharray', dashArray);
                }
                svg.appendChild(line);
            };

            const createWedge = (x1, y1, x2, y2, type, fillColor = bondColor) => {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const perpAngle = angle + Math.PI / 2;
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                if (type === 'wedge-up') {
                    const offset = WEDGE_WIDTH / 2;
                    const endOffX = offset * Math.cos(perpAngle);
                    const endOffY = offset * Math.sin(perpAngle);
                    const p1 = `${x1},${y1}`;
                    const p2 = `${x2 + endOffX},${y2 + endOffY}`;
                    const p3 = `${x2 - endOffX},${y2 - endOffY}`;
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', `${p1} ${p2} ${p3}`);
                    polygon.setAttribute('fill', fillColor);
                    polygon.setAttribute('stroke', 'none');
                    g.appendChild(polygon);
                } else if (type === 'wedge-down') {
                    const dashLength = 3;
                    const dashGap = 1.5;
                    let currentDist = 0;
                    while (currentDist < dist) {
                        const startRatio = currentDist / dist;
                        const endRatio = Math.min(1, (currentDist + dashLength) / dist);
                        const startWidth = WEDGE_WIDTH * (1 - startRatio);
                        const endWidth = WEDGE_WIDTH * (1 - endRatio);
                        const perpOffset1_start = { x: (startWidth / 2) * Math.cos(perpAngle), y: (startWidth / 2) * Math.sin(perpAngle) };
                        const perpOffset1_end = { x: (endWidth / 2) * Math.cos(perpAngle), y: (endWidth / 2) * Math.sin(perpAngle) };
                        const perpOffset2_start = { x: -(startWidth / 2) * Math.cos(perpAngle), y: -(startWidth / 2) * Math.sin(perpAngle) };
                        const perpOffset2_end = { x: -(endWidth / 2) * Math.cos(perpAngle), y: -(endWidth / 2) * Math.sin(perpAngle) };
                        const seg_x1 = x2 - startRatio * dx + perpOffset1_start.x;
                        const seg_y1 = y2 - startRatio * dy + perpOffset1_start.y;
                        const seg_x2 = x2 - endRatio * dx + perpOffset1_end.x;
                        const seg_y2 = y2 - endRatio * dy + perpOffset1_end.y;
                        const seg_x3 = x2 - startRatio * dx + perpOffset2_start.x;
                        const seg_y3 = y2 - startRatio * dy + perpOffset2_start.y;
                        const seg_x4 = x2 - endRatio * dx + perpOffset2_end.x;
                        const seg_y4 = y2 - endRatio * dy + perpOffset2_end.y;
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', `${seg_x1},${seg_y1} ${seg_x2},${seg_y2} ${seg_x4},${seg_y4} ${seg_x3},${seg_y3}`);
                        polygon.setAttribute('fill', fillColor);
                        polygon.setAttribute('stroke', 'none');
                        g.appendChild(polygon);
                        currentDist += dashLength + dashGap;
                    }
                }
                svg.appendChild(g);
            };

            bonds.forEach(b => {
                const a1 = atomMap.get(b.a1);
                const a2 = atomMap.get(b.a2);
                if (!a1 || !a2) return;
                const dx_total = a2.x - a1.x;
                const dy_total = a2.y - a1.y;
                const angle = Math.atan2(dy_total, dx_total);
                const perpAngle = angle + Math.PI / 2;
                let startOffset = 0;
                let endOffset = 0;
                if (a1.elem !== 'C') startOffset = BOND_END_OFFSET;
                if (a2.elem !== 'C') endOffset = BOND_END_OFFSET;
                const dist_total = Math.sqrt(dx_total * dx_total + dy_total * dy_total);
                const dist = dist_total - startOffset - endOffset;
                if (dist <= 0) return;
                const startX = a1.x + startOffset * Math.cos(angle);
                const startY = a1.y + startOffset * Math.sin(angle);
                const endX = a2.x - endOffset * Math.cos(angle);
                const endY = a2.y - endOffset * Math.sin(angle);
                const hotspot = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hotspot.setAttribute('x1', startX);
                hotspot.setAttribute('y1', startY);
                hotspot.setAttribute('x2', endX);
                hotspot.setAttribute('y2', endY);
                hotspot.setAttribute('class', `selectable-bond${selectedBonds.has(b.id) ? ' selected' : ''}`);
                hotspot.setAttribute('data-bond-id', b.id);
                svg.appendChild(hotspot);
                const strokeColor = selectedBonds.has(b.id) ? 'rgb(255, 255, 0)' : bondColor;
                const offset = BOND_TYPE_OFFSET;
                if (b.type === 'double') {
                    const offX = offset * Math.cos(perpAngle);
                    const offY = offset * Math.sin(perpAngle);
                    createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                    createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                } else if (b.type === 'triple') {
                    const offX = offset * Math.cos(perpAngle);
                    const offY = offset * Math.sin(perpAngle);
                    createLine(startX + offX, startY + offY, endX + offX, endY + offY, BOND_STROKE_WIDTH, strokeColor);
                    createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                    createLine(startX - offX, startY - offY, endX - offX, endY - offY, BOND_STROKE_WIDTH, strokeColor);
                } else if (b.type === 'wedge-up' || b.type === 'wedge-down') {
                    createWedge(startX, startY, endX, endY, b.type, strokeColor);
                } else {
                    createLine(startX, startY, endX, endY, BOND_STROKE_WIDTH, strokeColor);
                }
            });

            atoms.forEach(a => {
                const shouldDrawSymbol = !(a.elem === 'C' && bondCount[a.id] > 0);
                const clickableCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                clickableCircle.setAttribute('cx', a.x);
                clickableCircle.setAttribute('cy', a.y);
                clickableCircle.setAttribute('r', ATOM_RADIUS);
                clickableCircle.setAttribute('class', `selectable-atom${selectedAtoms.has(a.id) ? ' selected' : ''}`);
                clickableCircle.setAttribute('data-atom-id', a.id);
                svg.appendChild(clickableCircle);
                if (shouldDrawSymbol) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', a.x);
                    text.setAttribute('y', a.y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', getCssColor(a.elem));
                    text.setAttribute('font-size', ATOM_FONT_SIZE);
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = a.elem;
                    text.setAttribute('data-atom-id', a.id);
                    svg.appendChild(text);
                }
            });

            if (isSelecting && selectionRect) {
                svg.appendChild(selectionRect);
            }
        }

        function addAtom(elem, x, y) {
            const newAtom = { id: nextAtomId++, elem, x, y };
            atoms.push(newAtom);
            draw();
        }

        function addBond(id1, id2) {
            const existingBondIndex = bonds.findIndex(b => (b.a1 === id1 && b.a2 === id2) || (b.a1 === id2 && b.a2 === id1));
            if (existingBondIndex !== -1) {
                const bond = bonds[existingBondIndex];
                if (currentBond === 'single') {
                    if (bond.type === 'single') bond.type = 'double';
                    else if (bond.type === 'double') bond.type = 'triple';
                    else bond.type = 'single';
                } else {
                    bond.type = currentBond;
                }
            } else {
                bonds.push({ id: nextBondId++, a1: id1, a2: id2, type: currentBond });
            }
            draw();
        }

        function extendFrom(atomId, mouseX, mouseY) {
            const parentAtom = atoms.find(a => a.id === atomId);
            if (!parentAtom) return;
            const dx = mouseX - parentAtom.x;
            const dy = mouseY - parentAtom.y;
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += 2 * Math.PI;
            const bondAngles = [0, Math.PI / 6, Math.PI / 3, Math.PI / 2, 2 * Math.PI / 3, 5 * Math.PI / 6, Math.PI, 7 * Math.PI / 6, 4 * Math.PI / 3, 3 * Math.PI / 2, 5 * Math.PI / 3, 11 * Math.PI / 6, 2 * Math.PI];
            let closestAngle = bondAngles.reduce((prev, curr) => Math.abs(curr - angle) < Math.abs(prev - angle) ? curr : prev);
            const dist = 40;
            const newX = parentAtom.x + dist * Math.cos(closestAngle);
            const newY = parentAtom.y + dist * Math.sin(closestAngle);
            const overlappingAtom = atoms.find(a => Math.hypot(newX - a.x, newY - a.y) < ATOM_RADIUS);
            if (overlappingAtom) {
                addBond(parentAtom.id, overlappingAtom.id);
            } else {
                const newAtomId = nextAtomId;
                addAtom(currentTool, newX, newY);
                addBond(parentAtom.id, newAtomId);
            }
        }

        function clearSelection() {
            selectedAtoms.clear();
            selectedBonds.clear();
            if (selectionRect && selectionRect.parentNode) {
                selectionRect.parentNode.removeChild(selectionRect);
            }
            selectionBox = { left: 0, top: 0, right: 0, bottom: 0 };
            draw();
        }

        function isInsideSelectionBox(x, y) {
            const padding = 5;
            if (selectedAtoms.size === 0) return false;
            if (selectionBox.right - selectionBox.left === 0 || selectionBox.bottom - selectionBox.top === 0) return false;
            return x >= selectionBox.left - padding && x <= selectionBox.right + padding && y >= selectionBox.top - padding && y <= selectionBox.bottom + padding;
        }

        function getMousePos(e) {
            const rect = svg.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function updateCanvasCursor() {
            svg.style.cursor = mode === 'move' ? 'move' : mode === 'lasso' ? 'crosshair' : 'crosshair';
        }

        function deleteSelectedElements() {
            const atomsToDelete = new Set(selectedAtoms);
            const bondsToDelete = new Set(selectedBonds);
            if (atomsToDelete.size === 0 && bondsToDelete.size === 0) return;
            bonds.forEach(b => {
                if (atomsToDelete.has(b.a1) || atomsToDelete.has(b.a2)) {
                    bondsToDelete.add(b.id);
                }
            });
            bonds = bonds.filter(b => !bondsToDelete.has(b.id));
            atoms = atoms.filter(a => !atomsToDelete.has(a.id));
            clearSelection();
        }

        svg.addEventListener('mousedown', e => {
            const pos = getMousePos(e);
            dragStartPos = pos;
            const targetElem = e.target;
            const atomId = targetElem.getAttribute('data-atom-id');
            const bondId = targetElem.getAttribute('data-bond-id');

            if (mode === 'lasso') {
                if (selectedAtoms.size > 0 && isInsideSelectionBox(pos.x, pos.y)) {
                    isDraggingSelection = true;
                    if (selectionRect && selectionRect.parentNode) selectionRect.parentNode.removeChild(selectionRect);
                } else {
                    isSelecting = true;
                    startX = pos.x;
                    startY = pos.y;
                    if (selectionRect && selectionRect.parentNode) selectionRect.parentNode.removeChild(selectionRect);
                    selectionRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    selectionRect.setAttribute('id', 'selectionRect');
                    selectionRect.setAttribute('x', startX);
                    selectionRect.setAttribute('y', startY);
                    selectionRect.setAttribute('width', 0);
                    selectionRect.setAttribute('height', 0);
                    svg.appendChild(selectionRect);
                    clearSelection();
                }
            } else if (mode === 'move') {
                if (atomId) {
                    const id = parseInt(atomId);
                    if (!selectedAtoms.has(id)) {
                        clearSelection();
                        selectedAtoms.add(id);
                    }
                    isDraggingAtom = true;
                    dragTargetId = id;
                    const atom = atoms.find(a => a.id === dragTargetId);
                    dragStartOffset.x = pos.x - atom.x;
                    dragStartOffset.y = pos.y - atom.y;
                } else {
                    clearSelection();
                }
            } else { // draw mode
                if (atomId) {
                    isDraggingAtom = true;
                    dragTargetId = parseInt(atomId);
                } else if (bondId) {
                    const bond = bonds.find(b => b.id === parseInt(bondId));
                    if(bond) addBond(bond.a1, bond.a2); // Re-call addBond to cycle type
                } else if (e.target.tagName === 'svg') {
                    addAtom(currentTool, pos.x, pos.y);
                    clearSelection();
                }
            }
        });

        svg.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            if (isDraggingSelection) {
                const dx = pos.x - dragStartPos.x;
                const dy = pos.y - dragStartPos.y;
                selectedAtoms.forEach(id => {
                    const atom = atoms.find(a => a.id === id);
                    if (atom) { atom.x += dx; atom.y += dy; }
                });
                selectionBox.left += dx; selectionBox.right += dx;
                selectionBox.top += dy; selectionBox.bottom += dy;
                dragStartPos = pos;
                draw();
                return;
            }
            if (mode === 'lasso' && isSelecting) {
                const width = Math.abs(pos.x - startX);
                const height = Math.abs(pos.y - startY);
                const newX = Math.min(pos.x, startX);
                const newY = Math.min(pos.y, startY);
                selectionRect.setAttribute('x', newX);
                selectionRect.setAttribute('y', newY);
                selectionRect.setAttribute('width', width);
                selectionRect.setAttribute('height', height);
            } else if (mode === 'move' && isDraggingAtom) {
                const atom = atoms.find(a => a.id === dragTargetId);
                if (atom) {
                    atom.x = pos.x - dragStartOffset.x;
                    atom.y = pos.y - dragStartOffset.y;
                    draw();
                }
            } else {
                svg.querySelectorAll('.hover-effect').forEach(el => el.remove());
                const targetElem = e.target;
                const atomId = targetElem.getAttribute('data-atom-id');
                const bondId = targetElem.getAttribute('data-bond-id');
                if (atomId && !selectedAtoms.has(parseInt(atomId))) {
                    const atom = atoms.find(a => a.id === parseInt(atomId));
                    if (atom) {
                        const hoverCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        hoverCircle.setAttribute('cx', atom.x); hoverCircle.setAttribute('cy', atom.y);
                        hoverCircle.setAttribute('r', ATOM_RADIUS + 2);
                        hoverCircle.setAttribute('stroke', HOVER_COLOR); hoverCircle.setAttribute('stroke-width', 2);
                        hoverCircle.setAttribute('fill', 'none'); hoverCircle.setAttribute('class', 'hover-effect');
                        svg.appendChild(hoverCircle);
                    }
                } else if (bondId && !selectedBonds.has(parseInt(bondId))) {
                    const bond = bonds.find(b => b.id === parseInt(bondId));
                    const a1 = atoms.find(a => a.id === bond.a1);
                    const a2 = atoms.find(a => a.id === bond.a2);
                    if (bond && a1 && a2) {
                        const hoverLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hoverLine.setAttribute('x1', a1.x); hoverLine.setAttribute('y1', a1.y);
                        hoverLine.setAttribute('x2', a2.x); hoverLine.setAttribute('y2', a2.y);
                        hoverLine.setAttribute('stroke', HOVER_COLOR); hoverLine.setAttribute('stroke-width', 8);
                        hoverLine.setAttribute('class', 'hover-effect');
                        svg.appendChild(hoverLine);
                    }
                }
            }
        });

        svg.addEventListener('mouseup', e => {
            const pos = getMousePos(e);
            dragEndPos = pos;
            const dragDistance = Math.hypot(dragEndPos.x - dragStartPos.x, dragEndPos.y - dragStartPos.y);

            if (isDraggingSelection) {
                isDraggingSelection = false;
                draw();
                return;
            }

            if (mode === 'lasso') {
                isSelecting = false;
                if (selectionRect) { svg.removeChild(selectionRect); selectionRect = null; }
                if (dragDistance > CLICK_THRESHOLD) {
                    const left = Math.min(startX, pos.x), top = Math.min(startY, pos.y);
                    const width = Math.abs(startX - pos.x), height = Math.abs(startY - pos.y);
                    selectionBox = { left, top, right: left + width, bottom: top + height };
                    atoms.forEach(a => { if (a.x >= left && a.x <= left + width && a.y >= top && a.y <= top + height) selectedAtoms.add(a.id); });
                    bonds.forEach(b => { if (selectedAtoms.has(b.a1) && selectedAtoms.has(b.a2)) selectedBonds.add(b.id); });
                } else if (!isInsideSelectionBox(pos.x, pos.y)) {
                    clearSelection();
                }
                draw();
            } else if (mode === 'move') {
                isDraggingAtom = false;
                dragTargetId = null;
                draw();
            } else if (mode === 'draw' && isDraggingAtom) {
                if (dragDistance < CLICK_THRESHOLD) {
                    const targetAtom = atoms.find(a => a.id === dragTargetId);
                    if (targetAtom) targetAtom.elem = currentTool;
                } else {
                    const targetAtom = atoms.find(a => a.id !== dragTargetId && Math.hypot(pos.x - a.x, pos.y - a.y) < ATOM_RADIUS);
                    if (targetAtom) addBond(dragTargetId, targetAtom.id);
                    else extendFrom(dragTargetId, pos.x, pos.y);
                }
                isDraggingAtom = false;
                dragTargetId = null;
                draw();
            }
            svg.dispatchEvent(new MouseEvent('mousemove', { clientX: e.clientX, clientY: e.clientY }));
        });

        svg.addEventListener('mouseleave', () => {
            isSelecting = false; isDraggingAtom = false; isDraggingSelection = false; dragTargetId = null;
            if (selectionRect && selectionRect.parentNode) selectionRect.parentNode.removeChild(selectionRect);
            svg.querySelectorAll('.hover-effect').forEach(el => el.remove());
        });

        document.addEventListener('keydown', e => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                deleteSelectedElements();
            }
        });

        document.getElementById('exportPngBtn').addEventListener('click', () => {
            const svgElement = document.getElementById('draw-svg');
            clearSelection();
            svgElement.querySelectorAll('.hover-effect').forEach(el => el.remove());
            let bbox;
            try {
                bbox = svgElement.getBBox();
                if (bbox.width === 0 || bbox.height === 0) throw new Error();
            } catch (e) {
                alert('画布为空，无法导出！'); return;
            }
            const margin = 15;
            const width = bbox.width + 2 * margin, height = bbox.height + 2 * margin;
            const translateX = -bbox.x + margin, translateY = -bbox.y + margin;
            const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            tempSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            tempSvg.setAttribute('width', width); tempSvg.setAttribute('height', height);
            tempSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${translateX}, ${translateY})`);
            Array.from(svgElement.children).forEach(child => {
                const cls = child.getAttribute('class') || '';
                if (child.id === 'selectionRect' || cls.includes('selectable') || cls.includes('hover-effect')) return;
                const clonedChild = child.cloneNode(true);
                if (clonedChild.tagName === 'text') {
                    const atom = atoms.find(a => a.id === parseInt(clonedChild.getAttribute('data-atom-id')));
                    if (atom) clonedChild.setAttribute('fill', getCssColor(atom.elem));
                }
                if (clonedChild.tagName === 'line' && !clonedChild.getAttribute('stroke')) clonedChild.setAttribute('stroke', getCssColor('C'));
                if (clonedChild.tagName === 'g' || clonedChild.tagName === 'polygon' || clonedChild.tagName === 'path') {
                    const setFill = (el) => { if (!el.getAttribute('fill')) el.setAttribute('fill', getCssColor('C')); };
                    if (clonedChild.tagName === 'g') clonedChild.querySelectorAll('*').forEach(setFill);
                    else setFill(clonedChild);
                }
                g.appendChild(clonedChild);
            });
            tempSvg.appendChild(g);
            const svgData = new XMLSerializer().serializeToString(tempSvg);
            const url = URL.createObjectURL(new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' }));
            const img = new Image();
            img.onload = function () {
                const canvas = document.createElement('canvas');
                canvas.width = width; canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0);
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = 'molecular_structure_transparent.png';
                a.click();
                URL.revokeObjectURL(url);
            };
            img.src = url;
        });

        function mapBondSymbol(type) {
            const t = (type || 'single').toLowerCase();
            if (t === 'double') return '=';
            if (t === 'triple') return '#';
            return '-';
        }

        function downloadCsv(filename, content) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        document.getElementById('exportCsvBtn').addEventListener('click', () => {
            if (!atoms || atoms.length === 0) { alert('画布为空，无法导出 CSV！'); return; }
            clearSelection();
            svg.querySelectorAll('.hover-effect').forEach(el => el.remove());

            const sortedAtoms = atoms.slice().sort((x, y) => x.id - y.id);
            const atomLines = ['Seq,Symbol,X,Y,Z']; // Add X,Y,Z for 3D
            sortedAtoms.forEach(a => atomLines.push(`${a.id},${a.elem},${(a.x / 10).toFixed(4)},${(-a.y / 10).toFixed(4)},0.0`)); // Scale and invert Y

            const bondLines = ['A,B,BondType'];
            bonds.forEach(b => bondLines.push(`${b.a1},${b.a2},${mapBondSymbol(b.type)}`));

            downloadCsv('SXYZ.csv', atomLines.join('\n'));
            setTimeout(() => downloadCsv('ADJ_AB.csv', bondLines.join('\n')), 100);
        });

        document.querySelectorAll('#draw-container #toolbar button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.id === 'deleteBtn') { deleteSelectedElements(); return; }
                if (btn.id === 'exportPngBtn' || btn.id === 'exportCsvBtn') return;

                clearSelection();
                const parentGroup = btn.closest('.button-group');
                if (parentGroup) {
                   parentGroup.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                }
                btn.classList.add('active');

                if (btn.classList.contains('mode-btn')) {
                    mode = btn.id.replace('Btn', '');
                } else if (btn.classList.contains('atom-btn')) {
                    currentTool = btn.dataset.tool;
                    mode = 'draw';
                    document.querySelectorAll('#draw-container .mode-btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('drawBtn').classList.add('active');
                } else if (btn.classList.contains('bond-btn')) {
                    currentBond = btn.dataset.bond;
                    mode = 'draw';
                    document.querySelectorAll('#draw-container .mode-btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('drawBtn').classList.add('active');
                }
                updateCanvasCursor();
            });
        });

        document.getElementById('drawBtn').click();
        draw();
    })();
    </script>

    <!-- 3D_V3.html 脚本 (已封装) -->
    <script>
    window.d3App = (function() {
        const ATOM_RADII = { 'C': 0.77, 'H': 0.37, 'O': 0.73, 'N': 0.75, 'S': 1.02 };
        const ATOM_COLORS = { 'C': 0xBBBBBB, 'H': 0x888888, 'O': 0x6495ED, 'N': 0xB2B01D, 'S': 0xCC99A2 };
        const BALL_STICK_SCALE_FACTOR = 0.4, BOND_RADIUS_BALL_STICK = 0.08, STICK_RADIUS = 0.12;
        const HIGHLIGHT_COLOR = 0xFFFF00, INITIAL_CAMERA_DISTANCE = 15, AXIS_CAMERA_DISTANCE = 3.5;

        let scene, camera, renderer, controls, moleculeGroup, ambientLight, directionalLight;
        let atomMeshes = [], bondMeshes = [], highlightedAtom = null, sxyzData = null, adjData = null;
        let currentRenderType = 'ball_stick', currentBackgroundColor = 0x000000;
        let axisScene, axisCamera, axisRenderer, axisGroup, axisRendererContainer;
        const AXIS_SIZE = 80;

        const d3Container = document.getElementById('d3-container');

        function getLuminance(hexColor) {
            if (typeof hexColor === 'number') hexColor = '#' + hexColor.toString(16).padStart(6, '0');
            const r = parseInt(hexColor.slice(1, 3), 16) / 255, g = parseInt(hexColor.slice(3, 5), 16) / 255, b = parseInt(hexColor.slice(5, 7), 16) / 255;
            return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        }

        function getButtonTextColor(bgColorHex) { return getLuminance(bgColorHex) > 0.6 ? '#333333' : '#FFFFFF'; }

        function updateControlTextAndThemeColor(hexColor) {
            const root = d3Container.style;
            const isLightBackground = getLuminance(hexColor) > 0.3;
            const theme = isLightBackground ? 'dark' : 'light';
            root.setProperty('--current-text-color', `var(--color-text-${theme === 'dark' ? 'light' : 'dark'})`);
            ['load', 'light', 'params', 'export'].forEach(type => {
                root.setProperty(`--current-${type}-color`, `var(--color-${type}-${theme})`);
            });
            root.setProperty('--current-toggle-active', `var(--color-params-${theme})`);
            setupUIStyles();
            const textColor = getComputedStyle(d3Container).getPropertyValue('--current-text-color');
            d3Container.querySelector('#background-color-picker-container').style.borderColor = textColor;
            d3Container.querySelectorAll('.color-swatch').forEach(swatch => swatch.style.borderColor = textColor);
        }

        function updateInfoTextColor(hexColor) {
            const textColor = getLuminance(hexColor) > 0.5 ? '#000000' : '#FFFFFF';
            d3Container.querySelector('#highlight-info').style.color = textColor;
            d3Container.querySelector('#controls-label').style.color = textColor;
            d3Container.querySelector('#toggle-button-wrapper').style.color = textColor;
        }

        function colorToHex(color) {
            if (typeof color === 'number') return '#' + color.toString(16).padStart(6, '0').toUpperCase();
            if (color instanceof THREE.Color) return '#' + color.getHexString().toUpperCase();
            return '#--';
        }

        function updateHighlightInfo(atom) {
            const symbolEl = d3Container.querySelector('#highlight-symbol'), indexEl = d3Container.querySelector('#highlight-index');
            const colorEl = d3Container.querySelector('#highlight-color'), coordsEl = d3Container.querySelector('#highlight-coords');
            if (atom && atom.userData) {
                const data = atom.userData;
                symbolEl.textContent = data.symbol;
                indexEl.textContent = data.index;
                const colorHex = colorToHex(data.baseColor);
                colorEl.textContent = colorHex;
                colorEl.style.color = colorHex;
                coordsEl.textContent = `(${(data.X || 0).toFixed(2)}, ${(data.Y || 0).toFixed(2)}, ${(data.Z || 0).toFixed(2)})`;
            } else {
                symbolEl.textContent = '无'; indexEl.textContent = '--';
                colorEl.textContent = '#--'; colorEl.style.color = 'inherit';
                coordsEl.textContent = '----';
            }
        }

        function exportView(format) {
            if (format !== 'png' || !renderer) return;
            const originalBackground = scene.background, originalAlpha = renderer.getClearAlpha();
            scene.background = null; renderer.setClearAlpha(0); renderer.render(scene, camera);
            const imgData = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'molecule_3d_view.png';
            link.href = imgData;
            link.click();
            renderer.setClearAlpha(originalAlpha); scene.background = originalBackground; renderer.render(scene, camera);
        }

        function clearHighlight() {
            if (highlightedAtom) {
                highlightedAtom.material.emissive.set(0x000000);
                highlightedAtom = null;
            }
            bondMeshes.forEach(mesh => { if (mesh.userData.isBond) mesh.material.emissive.set(0x000000); });
            updateHighlightInfo(null);
        }

        function highlightAtomAndBonds(atom) {
            clearHighlight();
            if (!atom) return;
            atom.material.emissive.set(HIGHLIGHT_COLOR);
            highlightedAtom = atom;
            updateHighlightInfo(atom);
            if (currentRenderType !== 'stick') return;
            const atomIndex = highlightedAtom.userData.index;
            bondMeshes.forEach(mesh => {
                if (mesh.userData.isBond) {
                    const { atomAIndex, atomBIndex, atomSide } = mesh.userData;
                    if ((atomAIndex === atomIndex && atomSide === 'A') || (atomBIndex === atomIndex && atomSide === 'B')) {
                        mesh.material.emissive.set(HIGHLIGHT_COLOR);
                    }
                }
            });
        }

        function initAxisHelper() {
            axisRendererContainer = d3Container.querySelector('#axis-renderer-container');
            axisScene = new THREE.Scene();
            axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            axisCamera.position.set(AXIS_CAMERA_DISTANCE, AXIS_CAMERA_DISTANCE, AXIS_CAMERA_DISTANCE);
            axisCamera.up.set(0, 1, 0); axisCamera.lookAt(0, 0, 0);
            axisRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            axisRenderer.setSize(AXIS_SIZE, AXIS_SIZE);
            axisRenderer.setClearColor(0x000000, 0);
            axisRendererContainer.appendChild(axisRenderer.domElement);
            axisGroup = new THREE.Group();
            axisScene.add(axisGroup);
            const axesData = [
                { dir: new THREE.Vector3(1.5, 0, 0), color: 0xD62828, text: 'X' },
                { dir: new THREE.Vector3(0, 1.5, 0), color: 0x008000, text: 'Y' },
                { dir: new THREE.Vector3(0, 0, 1.5), color: 0x0000FF, text: 'Z' },
            ];
            const cylGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 16);
            axesData.forEach(data => {
                const material = new THREE.MeshBasicMaterial({ color: data.color });
                const cylinder = new THREE.Mesh(cylGeom, material);
                cylinder.position.copy(data.dir).multiplyScalar(0.5);
                cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), data.dir.clone().normalize());
                axisGroup.add(cylinder);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: createTextTexture(data.text, data.color), sizeAttenuation: false, depthTest: false }));
                sprite.position.copy(data.dir).add(new THREE.Vector3(0.3, 0.3, 0.3));
                sprite.scale.set(0.3, 0.3, 0.3);
                axisGroup.add(sprite);
            });
            axisScene.add(new THREE.AmbientLight(0xFFFFFF, 1.0));
        }

        function createTextTexture(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64; canvas.height = 64;
            context.font = 'Bold 30px Arial';
            context.fillStyle = '#' + new THREE.Color(color).getHexString();
            context.textAlign = 'center'; context.textBaseline = 'middle';
            context.fillText(text, 32, 37);
            return new THREE.CanvasTexture(canvas);
        }

        function updateAxisHelper() {
            if (!axisGroup || !controls) return;
            axisGroup.quaternion.copy(camera.quaternion).invert(); // Invert to make it stationary
            axisRenderer.render(axisScene, axisCamera);
        }

        function onWindowResize() {
            const rect = d3Container.getBoundingClientRect();
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            renderer.setSize(rect.width, rect.height);
            if (axisCamera) {
                axisCamera.aspect = 1;
                axisCamera.updateProjectionMatrix();
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(currentBackgroundColor);
            camera = new THREE.PerspectiveCamera(75, d3Container.clientWidth / d3Container.clientHeight, 0.1, 1000);
            camera.position.set(-INITIAL_CAMERA_DISTANCE, -INITIAL_CAMERA_DISTANCE, -INITIAL_CAMERA_DISTANCE);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(d3Container.clientWidth, d3Container.clientHeight);
            d3Container.appendChild(renderer.domElement);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '0';

            initAxisHelper();
            updateInfoTextColor(currentBackgroundColor);
            updateControlTextAndThemeColor(currentBackgroundColor);

            ambientLight = new THREE.AmbientLight(0x404040, 4.0);
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.0);
            directionalLight.position.set(10, 10, 10).normalize();
            scene.add(directionalLight);
            setLightPreset('3d');

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            // 修正 #2: 更改鼠标操作逻辑
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,
                MIDDLE: THREE.MOUSE.ROTATE,
                RIGHT: THREE.MOUSE.DOLLY
            };
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.addEventListener('change', updateAxisHelper);

            const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();

            // 修正 #2: 避免平移时触发点击高亮事件
            let isDragging = false;
            renderer.domElement.addEventListener('pointerdown', () => { isDragging = false; });
            renderer.domElement.addEventListener('pointermove', () => { isDragging = true; });
            renderer.domElement.addEventListener('pointerup', (event) => {
                if(isDragging) return; // 如果是拖拽（平移/旋转）结束，则不触发高亮

                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(atomMeshes);
                const newHighlightedAtom = intersects.length > 0 ? intersects[0].object : null;
                if (highlightedAtom === newHighlightedAtom) clearHighlight();
                else highlightAtomAndBonds(newHighlightedAtom);
            }, false);


            window.addEventListener('resize', onWindowResize, false);
            setupLightControls();
            setupParamsControls();
            setupToggleControl();
            onWindowResize();
            controls.target.set(0, 0, 0);
            controls.update();
            updateAxisHelper();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls.enabled) controls.update();
            renderer.render(scene, camera);
            updateAxisHelper();
        }

        function setupUIStyles() {
            const root = getComputedStyle(d3Container);
            const colors = {
                load: root.getPropertyValue('--current-load-color').trim(),
                light: root.getPropertyValue('--current-light-color').trim(),
                export: root.getPropertyValue('--current-export-color').trim(),
                params: root.getPropertyValue('--current-params-color').trim(),
            };
            d3Container.querySelector('#file-input-panel h3').style.color = colors.load;
            d3Container.querySelectorAll('#file-input-panel .load-button').forEach(btn => { btn.style.backgroundColor = colors.load; btn.style.color = getButtonTextColor(colors.load); });
            d3Container.querySelector('#status-message').style.color = colors.load;
            d3Container.querySelector('#light-controls-panel h3').style.color = colors.light;
            d3Container.querySelectorAll('#light-controls-panel .light-button').forEach(btn => { btn.style.backgroundColor = colors.light; btn.style.color = getButtonTextColor(colors.light); });
            d3Container.querySelector('#params-controls-panel h3').style.color = colors.params;
            d3Container.querySelector('#export-controls-panel h3').style.color = colors.export;
            const exportBtn = d3Container.querySelector('#export-controls-panel .export-button');
            exportBtn.style.backgroundColor = colors.export;
            exportBtn.style.color = getButtonTextColor(colors.export);
        }

        function setLightPreset(preset) {
            const p = preset === 'clear' ? { a: 4.0, d: 0.1 } : { a: 2.5, d: 0.8 };
            ambientLight.intensity = p.a;
            directionalLight.intensity = p.d;
            d3Container.querySelector('#ambient-light-range').value = p.a;
            d3Container.querySelector('#directional-light-range').value = p.d;
            d3Container.querySelector('#ambient-value').textContent = p.a.toFixed(1);
            d3Container.querySelector('#directional-value').textContent = p.d.toFixed(1);
        }

        function setupLightControls() {
            const ambientRange = d3Container.querySelector('#ambient-light-range'), dirRange = d3Container.querySelector('#directional-light-range');
            const ambientVal = d3Container.querySelector('#ambient-value'), dirVal = d3Container.querySelector('#directional-value');
            ambientRange.addEventListener('input', (e) => { ambientLight.intensity = parseFloat(e.target.value); ambientVal.textContent = ambientLight.intensity.toFixed(1); });
            dirRange.addEventListener('input', (e) => { directionalLight.intensity = parseFloat(e.target.value); dirVal.textContent = directionalLight.intensity.toFixed(1); });
        }

        function setupParamsControls() {
            const picker = d3Container.querySelector('#background-color-picker'), container = d3Container.querySelector('#background-color-picker-container');
            const hydrogenToggle = d3Container.querySelector('#show-hydrogen'), swatches = d3Container.querySelectorAll('.color-swatch');
            const updateBg = (hex) => {
                if (!scene) return;
                scene.background.set(hex);
                currentBackgroundColor = scene.background.getHex();
                container.style.backgroundColor = hex;
                updateInfoTextColor(currentBackgroundColor);
                updateControlTextAndThemeColor(currentBackgroundColor);
            };
            picker.addEventListener('input', (e) => updateBg(e.target.value));
            swatches.forEach(s => s.addEventListener('click', (e) => { const c = e.target.dataset.color; picker.value = c; updateBg(c); }));
            hydrogenToggle.addEventListener('change', () => { if (sxyzData && adjData) drawMolecule(currentRenderType, sxyzData, adjData); });
            updateBg(picker.value);
        }

        function setupToggleControl() {
            const toggle = d3Container.querySelector('#controls-toggle'), wrapper = d3Container.querySelector('#controls-container-wrapper');
            const updateTransform = () => wrapper.style.transform = toggle.checked ? 'translateX(0)' : `translateX(${wrapper.offsetWidth + 20}px)`;
            updateTransform();
            toggle.addEventListener('change', updateTransform);
            new ResizeObserver(updateTransform).observe(wrapper);
        }

        function loadCSVFile(fileId) {
            return new Promise((resolve, reject) => {
                const fileInput = d3Container.querySelector(`#${fileId}`);
                if (!fileInput.files.length) return reject(new Error(`请选择 ${fileId.toUpperCase().replace('-', '.')} 文件。`));
                Papa.parse(fileInput.files[0], {
                    header: true, dynamicTyping: true, skipEmptyLines: true,
                    complete: (res) => resolve(res.data),
                    error: (err) => reject(new Error(`解析 ${fileId} 错误: ${err.message}`))
                });
            });
        }

        async function loadAndDraw(renderType) {
            const status = d3Container.querySelector('#status-message');
            status.textContent = "正在加载...";
            try {
                sxyzData = await loadCSVFile('sxyz-file');
                adjData = await loadCSVFile('adj-file');
                if (!sxyzData || sxyzData.length === 0) throw new Error("SXYZ.csv 数据为空。");
                if (!adjData || adjData.length === 0) throw new Error("ADJ_AB.csv 数据为空。");
                currentRenderType = renderType;
                drawMolecule(renderType, sxyzData, adjData);
                status.textContent = `渲染完成 (${renderType === 'ball_stick' ? '球棍' : '棒状'}模型)。`;
            } catch (error) {
                status.textContent = `错误: ${error.message}`;
            }
        }

        function drawMolecule(renderType, sxyzData, adjData) {
            if (moleculeGroup) scene.remove(moleculeGroup);
            atomMeshes = []; bondMeshes = []; clearHighlight();
            moleculeGroup = new THREE.Group();
            scene.add(moleculeGroup);
            const showH = d3Container.querySelector('#show-hydrogen').checked;
            const drawFunc = renderType === 'stick' ? drawAtomsAndBonds_Stick : drawAtomsAndBonds_BallStick;
            drawFunc(sxyzData, adjData, showH);
            centerAndZoom(sxyzData);
        }

        function drawAtomsAndBonds_BallStick(sxyzData, adjData, showH) {
            const atomGeom = new THREE.SphereGeometry(1, 32, 32);
            sxyzData.forEach((atom, index) => {
                const symbol = String(atom.Symbol).trim().toUpperCase();
                if (!showH && symbol === 'H') return;
                const radius = (ATOM_RADII[symbol] || 0.5) * BALL_STICK_SCALE_FACTOR;
                const color = ATOM_COLORS[symbol] || 0xCCCCCC;
                const material = new THREE.MeshStandardMaterial({ color, emissive: 0x0, metalness: 0.1, roughness: 0.5 });
                const mesh = new THREE.Mesh(atomGeom, material);
                mesh.scale.set(radius, radius, radius);
                mesh.position.set(atom.X, atom.Y, atom.Z);
                mesh.userData = { ...atom, symbol, index: index + 1, baseColor: color, isAtom: true };
                atomMeshes.push(mesh);
                moleculeGroup.add(mesh);
            });
            const bondGeom = new THREE.CylinderGeometry(BOND_RADIUS_BALL_STICK, BOND_RADIUS_BALL_STICK, 1, 16);
            const bondMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.1, roughness: 0.8 });
            adjData.forEach(bond => {
                const iA = (bond.A || 0) - 1, iB = (bond.B || 0) - 1;
                if (iA < 0 || iB < 0 || iA >= sxyzData.length || iB >= sxyzData.length) return;
                const sA = String(sxyzData[iA].Symbol).trim().toUpperCase(), sB = String(sxyzData[iB].Symbol).trim().toUpperCase();
                if (!showH && (sA === 'H' || sB === 'H')) return;
                const posA = new THREE.Vector3(sxyzData[iA].X, sxyzData[iA].Y, sxyzData[iA].Z);
                const posB = new THREE.Vector3(sxyzData[iB].X, sxyzData[iB].Y, sxyzData[iB].Z);
                const center = new THREE.Vector3().addVectors(posA, posB).divideScalar(2);
                const bondMesh = new THREE.Mesh(bondGeom, bondMat.clone());
                bondMesh.scale.set(1, posA.distanceTo(posB), 1);
                bondMesh.position.copy(center);
                bondMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(posB, posA).normalize());
                bondMesh.userData = { isBond: true, atomAIndex: iA + 1, atomBIndex: iB + 1 };
                bondMeshes.push(bondMesh);
                moleculeGroup.add(bondMesh);
            });
        }

        function drawAtomsAndBonds_Stick(sxyzData, adjData, showH) {
            const atomGeom = new THREE.SphereGeometry(1, 32, 32);
            sxyzData.forEach((atom, index) => {
                const symbol = String(atom.Symbol).trim().toUpperCase();
                if (!showH && symbol === 'H') return;
                const color = ATOM_COLORS[symbol] || 0xCCCCCC;
                const material = new THREE.MeshStandardMaterial({ color, emissive: 0x0, metalness: 0.1, roughness: 0.5 });
                const mesh = new THREE.Mesh(atomGeom, material);
                mesh.scale.set(STICK_RADIUS, STICK_RADIUS, STICK_RADIUS);
                mesh.position.set(atom.X, atom.Y, atom.Z);
                mesh.userData = { ...atom, symbol, index: index + 1, baseColor: color, isAtom: true };
                atomMeshes.push(mesh);
                moleculeGroup.add(mesh);
            });
            const bondGeom = new THREE.CylinderGeometry(STICK_RADIUS, STICK_RADIUS, 1, 16);
            adjData.forEach(bond => {
                const iA = (bond.A || 0) - 1, iB = (bond.B || 0) - 1;
                if (iA < 0 || iB < 0 || iA >= sxyzData.length || iB >= sxyzData.length) return;
                const sA = String(sxyzData[iA].Symbol).trim().toUpperCase(), sB = String(sxyzData[iB].Symbol).trim().toUpperCase();
                if (!showH && (sA === 'H' || sB === 'H')) return;
                const cA = ATOM_COLORS[sA] || 0xCCCCCC, cB = ATOM_COLORS[sB] || 0xCCCCCC;
                const posA = new THREE.Vector3(sxyzData[iA].X, sxyzData[iA].Y, sxyzData[iA].Z);
                const posB = new THREE.Vector3(sxyzData[iB].X, sxyzData[iB].Y, sxyzData[iB].Z);
                const halfDist = posA.distanceTo(posB) / 2;
                const dir = new THREE.Vector3().subVectors(posB, posA).normalize();
                const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                ['A', 'B'].forEach(side => {
                    const mat = new THREE.MeshStandardMaterial({ color: side === 'A' ? cA : cB, emissive: 0x0, metalness: 0.1, roughness: 0.8 });
                    const mesh = new THREE.Mesh(bondGeom, mat);
                    mesh.scale.set(1, halfDist, 1);
                    mesh.position.copy(side === 'A' ? posA : posB).addScaledVector(dir, side === 'A' ? halfDist / 2 : -halfDist / 2);
                    mesh.quaternion.copy(quat);
                    mesh.userData = { isBond: true, atomAIndex: iA + 1, atomBIndex: iB + 1, atomSide: side };
                    bondMeshes.push(mesh);
                    moleculeGroup.add(mesh);
                });
            });
        }

        function centerAndZoom(sxyzData) {
            if (!moleculeGroup || sxyzData.length === 0) return;
            const box = new THREE.Box3().setFromObject(moleculeGroup);
            const center = new THREE.Vector3();
            box.getCenter(center);
            moleculeGroup.position.sub(center);
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            let camDist = Math.abs(maxDim / 2 / Math.tan(camera.fov * (Math.PI / 180) / 2)) * 1.5;
            controls.target.set(0, 0, 0);
            const d = camDist / Math.sqrt(3);
            camera.position.set(-d, -d, -d).multiplyScalar(1.7);
            camera.lookAt(controls.target);
            controls.update();
        }

        init();
        d3Container.querySelector('#status-message').textContent = "请选择 SXYZ.csv 和 ADJ_AB.csv 文件。";

        // Expose public methods
        return {
            loadAndDraw,
            setLightPreset,
            exportView,
            onWindowResize,
            controls // Expose controls to disable/enable during resize
        };
    })();
    </script>

</body>
</html>