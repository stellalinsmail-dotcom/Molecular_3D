##### 优化函数1

```matlab
% 参数设置
maxmin_arr=table2array(max_xyz);
xyz_min = min(maxmin_arr,[],"all")*10  % 请替换为实际的最小值
xyz_max = max(maxmin_arr,[],"all")*10 % 请替换为实际的最大值

% 将初始坐标矩阵转换为向量（fmincon需要向量输入）
x0 = pre_xyz_tb(:);  % 将n×3矩阵展平为3n×1向量

% 设置边界约束
n = size(pre_xyz_tb, 1);
lb = xyz_min * ones(size(x0));  % 下界向量
ub = xyz_max * ones(size(x0));  % 上界向量

% 配置fmincon选项
options = optimoptions('fmincon', ...
    'Display', 'iter', ...          % 显示迭代过程
    'Algorithm', 'interior-point', ... % 内点法，适合处理边界约束
    'MaxFunctionEvaluations', 1000, ... % 最大函数评估次数
    'MaxIterations', 20, ...      % 最大迭代次数
    'OptimalityTolerance', 1e-6, ... % 优化容差
    'StepTolerance', 1e-6, ...      % 步长容差
    'ConstraintTolerance', 1e-6);   % 约束容差

% 定义目标函数包装器
objective_function = @(x_vector) objective_wrapper(x_vector, nh_tb, big_adj_list, mtype_all_arr);

% 执行优化
fprintf('开始优化...\n');
tic;
[x_opt_vector, fval, exitflag, output] = fmincon(objective_function, x0, ...
    [], [], [], [], lb, ub, [], options);
optimization_time = toc;

% 将优化结果转换回矩阵形式
xyz_tb_optimized = reshape(x_opt_vector, size(pre_xyz_tb));

% 显示优化结果
fprintf('优化完成！\n');
fprintf('优化时间: %.2f 秒\n', optimization_time);
fprintf('最终目标函数值: %f\n', fval);
fprintf('退出标志: %d\n', exitflag);
fprintf('迭代次数: %d\n', output.iterations);
fprintf('函数评估次数: %d\n', output.funcCount);

% 检查边界约束是否满足
if any(xyz_tb_optimized(:) < xyz_min) || any(xyz_tb_optimized(:) > xyz_max)
    fprintf('警告: 部分结果超出边界约束！\n');
    below_min = sum(xyz_tb_optimized(:) < xyz_min);
    above_max = sum(xyz_tb_optimized(:) > xyz_max);
    fprintf('低于下界的变量数: %d\n', below_min);
    fprintf('高于上界的变量数: %d\n', above_max);
else
    fprintf('所有变量均在边界约束内。\n');
end

% 目标函数包装器
function sumE = objective_wrapper(x_vector, nh_tb, big_adj_list, mtype_all_arr)
    % 将向量重新转换为坐标矩阵
    n = length(x_vector) / 3;
    xyz_tb = reshape(x_vector, [n, 3]);
    
    % 调用原始的目标函数
    [sumE,~,~,~,~,~,~] = getE(xyz_tb, nh_tb, big_adj_list, mtype_all_arr);
end
```

###### 优化结果

<img src="C:\Users\Crystal\AppData\Roaming\Typora\typora-user-images\image-20251012140744387.png" alt="image-20251012140744387" style="zoom: 50%;" />

出现重叠

| 优化前                                                       | 优化后                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| pre_xyz_tb = 11×3    <br/>         0         0         0<br/>         0         0    1.5080<br/>         0    1.4215    2.0114<br/>    1.0303         0   -0.3649<br/>   -0.5152    0.8923   -0.3649<br/>   -0.5152   -0.8923   -0.3649<br/>   -0.8923   -0.5152    1.8729<br/>    0.8923   -0.5152    1.8729<br/>   -1.0303    1.7654    2.1332<br/>    0.5152    1.4676    2.9743 | xyz_tb_optimized = 11×3    <br/>    0.0940    0.0845   -0.1539<br/>    0.4265    0.2956    1.6912<br/>    0.4845    1.3226    2.0476<br/>    0.0928    0.0804   -0.1518<br/>    0.0965    0.0843   -0.1531<br/>    0.0934    0.0865   -0.1536<br/>   -0.5855   -0.3513    1.8300<br/>    0.4279    0.2955    1.6914<br/>   -1.0353    1.7751    2.1393<br/>    0.4825    1.3223    2.0479 |



##### 优化函数2

```matlab
% 参数设置
ratio = 10;
maxmin_arr = table2array(max_xyz);  % 需要替换为你的实际数据
xyz_min = min(maxmin_arr, [], "all") * ratio;  % 实际的最小值
xyz_max = max(maxmin_arr, [], "all") * ratio;  % 实际的最大值

% 将初始坐标矩阵展平为向量
x0 = pre_xyz_tb(:);  % 将n×3矩阵展平为3n×1向量

% 设置PSO的搜索空间
n = size(pre_xyz_tb, 1);  % 原子数目
lower_bound = xyz_min * ones(size(x0));  % 搜索空间下界
upper_bound = xyz_max * ones(size(x0));  % 搜索空间上界

% 增加随机性和多次重启策略
num_runs = 5;  % 进行5次独立优化尝试，每次使用不同的初始值
best_fval = Inf;
best_x_opt = [];

for run = 1:num_runs
    % 每次运行时生成不同的初始粒子群
    initial_swarm = xyz_min + (xyz_max - xyz_min) * rand(100, n*3);  % 随机生成初始粒子群
    
    % PSO参数设置
    options = optimoptions('particleswarm', ...
        'SwarmSize', 100, ...               % 粒子群大小
        'MaxIterations', 500, ...           % 最大迭代次数
        'Display', 'iter', ...              % 显示优化过程
        'FunctionTolerance', 1e-6, ...      % 设置较小的目标函数容差
        'InitialSwarmMatrix', initial_swarm, ...  % 初始粒子群矩阵
        'InertiaWeight', 0.7, ...           % 惯性权重
        'SocialCoefficient', 1.5, ...       % 社会认知因子
        'CognitiveCoefficient', 1.5, ...    % 认知因子
        'OutputFcn', @psoOutputFunction);   % 输出函数

    % 目标函数包装器
    objective_function = @(x_vector) objective_wrapper(x_vector, nh_tb, big_adj_list, mtype_all_arr);

    % 执行粒子群优化
    fprintf('开始第 %d 次优化...\n', run);
    tic;
    [x_opt_vector, fval] = particleswarm(objective_function, length(x0), lower_bound, upper_bound, options);
    optimization_time = toc;

    % 如果当前结果更好，则更新最优解
    if fval < best_fval
        best_fval = fval;
        best_x_opt = x_opt_vector;
    end

    % 显示每次优化的时间和目标函数值
    fprintf('第 %d 次优化完成！\n', run);
    fprintf('优化时间: %.2f 秒\n', optimization_time);
    fprintf('当前目标函数值: %f\n', fval);
end

% 将最终优化结果转换回矩阵形式
opt_xyz_tb = reshape(best_x_opt, size(pre_xyz_tb));

% 显示最终优化结果
fprintf('全局最优解已找到！\n');
fprintf('优化完成，最优目标函数值: %f\n', best_fval);
fprintf('最终优化时间: %.2f 秒\n', optimization_time);

% 目标函数包装器
function sumE = objective_wrapper(x_vector, nh_tb, big_adj_list, mtype_all_arr)
    % 将向量重新转换为坐标矩阵
    n = length(x_vector) / 3;
    xyz_tb = reshape(x_vector, [n, 3]);
    
    % 检查输入的 xyz_tb 是否符合预期的尺寸
    if size(xyz_tb, 1) ~= n
        error('xyz_tb 的行数与原子数目不匹配！');
    end
    
    % 调用原始的目标函数
    [sumE, ~, ~, ~, ~, ~, ~] = getE(xyz_tb, nh_tb, big_adj_list, mtype_all_arr);
end

% 自定义输出函数
function stop = psoOutputFunction(~, optimValues, ~)
    stop = false;
    % 检查 optimValues 中的字段名，避免错误访问
    if isfield(optimValues, 'Generation') && isfield(optimValues, 'BestFitness')
        % 每20次迭代输出一次中间结果
        if mod(optimValues.Generation, 20) == 0
            fprintf('迭代次数: %d, 当前目标函数值: %.4f\n', ...
                optimValues.Generation, optimValues.BestFitness);
        end
    else
        % 输出其他可用信息（如果字段名有所不同）
        disp('当前optimValues中没有Generation或BestFitness字段');
    end
end

```

